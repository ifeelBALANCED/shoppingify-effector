{"version":3,"file":"forest.mjs","sources":["forest/plan/index.ts","forest/platform/env.ts","forest/bindings.ts","forest/template.ts","forest/search.ts","forest/assert.ts","forest/mountChild.ts","forest/mutualSample.ts","forest/forIn.ts","forest/method/handler.ts","forest/method/spec.ts","forest/method/h.ts","forest/method/using.ts","forest/iterateChildLeafs.ts","forest/unmount.ts","forest/method/remap.ts","forest/method/list.ts","forest/method/node.ts","forest/method/route.ts","forest/method/variant.ts","forest/method/rec.ts","forest/method/tree.ts","forest/method/block.ts","forest/wordsArray.ts","forest/method/text.ts","forest/method/val.ts","forest/platform/now.ts","forest/platform/mark.ts","forest/platform/raf.ts","forest/templateHandlers.ts","forest/mountFn.ts"],"sourcesContent":["import {TASK_DEADLINE} from '../platform/env'\nimport {now} from '../platform/now'\nimport {beginMark, endMark} from '../platform/mark'\nimport {raf} from '../platform/raf'\nimport type {\n  Op,\n  OpPriorityQueue,\n  OpGroup,\n  AsyncValue,\n  Linkable,\n} from './index.h'\n\nfunction addItemToQueue(\n  queue: {first: Linkable | null; last: Linkable | null},\n  item: Linkable,\n) {\n  if (queue.last) {\n    item.cursor.prev = queue.last\n    queue.last.cursor.next = item\n    queue.last = item\n  } else {\n    queue.first = queue.last = item\n  }\n}\n\nfunction removeItemFromQueue(\n  queue: {first: Linkable | null; last: Linkable | null},\n  item: Linkable,\n) {\n  if (item.cursor.prev) {\n    item.cursor.prev.cursor.next = item.cursor.next\n  }\n  if (item.cursor.next) {\n    item.cursor.next.cursor.prev = item.cursor.prev\n  }\n  if (queue.last === item) {\n    queue.last = item.cursor.prev\n  }\n  if (queue.first === item) {\n    queue.first = item.cursor.next\n  }\n  item.cursor.prev = null\n  item.cursor.next = null\n}\n\n//prettier-ignore\nfunction removeOpGroupFromQueue(\n  group: OpGroup,\n  priority: 'props' | 'tree' | 'data'\n) {\n  if (group.cursor[priority].prev) {\n    group.cursor[priority].prev!.cursor[priority].next = group.cursor[priority].next\n  }\n  if (group.cursor[priority].next) {\n    group.cursor[priority].next!.cursor[priority].prev = group.cursor[priority].prev\n  }\n  if (group.queue[priority].last === group) {\n    group.queue[priority].last = group.cursor[priority].prev\n  }\n  if (group.queue[priority].first === group) {\n    group.queue[priority].first = group.cursor[priority].next\n  }\n  group.cursor[priority].prev = null\n  group.cursor[priority].next = null\n}\n\nfunction removeOpFromQueue(op: Op) {\n  op.status = 'active'\n  removeItemFromQueue(getOpQueue(op), op)\n}\n\nfunction addOpGroupToQueue(\n  group: OpGroup,\n  priority: 'props' | 'tree' | 'data',\n) {\n  if (group.queue[priority].last) {\n    group.cursor[priority].prev = group.queue[priority].last\n    group.queue[priority].last!.cursor[priority].next = group\n    group.queue[priority].last = group\n  } else {\n    group.queue[priority].first = group.queue[priority].last = group\n  }\n}\n\nfunction getOpQueue(op: Op) {\n  return op.group.activeChilds[op.priority]\n}\n\nexport function forceSetOpValue(value: any, op: Op) {\n  op.value.active = op.value.pending = value\n  if (op.status === 'active') return\n  removeOpFromQueue(op)\n}\n\nexport function pushOpToQueue(value: any, op: Op) {\n  if (op.value.active === value) {\n    op.value.pending = value\n    if (op.status === 'pending') {\n      removeOpFromQueue(op)\n      if (!getOpQueue(op).first) {\n        removeOpGroupFromQueue(op.group, op.priority)\n      }\n    }\n    return\n  }\n  if (op.status === 'active') {\n    op.status = 'pending'\n    if (!getOpQueue(op).first) {\n      addOpGroupToQueue(op.group, op.priority)\n    }\n    addItemToQueue(getOpQueue(op), op)\n  }\n  op.value.pending = value\n  if (!op.group.queue.rafID) {\n    op.group.queue.rafID = raf(op.group.queue.execQueue)\n  }\n}\n\nfunction execQueue(queue: OpPriorityQueue) {\n  beginMark('execQueue')\n  const start = now()\n  let interrupted = false\n  let group: OpGroup | null\n  let op: Op | null\n\n  quant: {\n    while (queue.props.first || queue.tree.first || queue.data.first) {\n      if (now() - start >= TASK_DEADLINE) {\n        interrupted = true\n        break quant\n      }\n      const hasPropsTasks = !!queue.props.first\n      if (hasPropsTasks) beginMark('props')\n\n      while ((group = queue.props.first)) {\n        while ((op = group.activeChilds.props.first)) {\n          if (now() - start >= TASK_DEADLINE) {\n            interrupted = true\n            endMark('props')\n            break quant\n          }\n          op.runOp(op.value.pending)\n          op.value.active = op.value.pending\n          removeOpFromQueue(op)\n        }\n        removeOpGroupFromQueue(group, 'props')\n      }\n      if (hasPropsTasks) endMark('props')\n\n      const hasTreeTasks = !!queue.tree.first\n      if (hasTreeTasks) beginMark('tree')\n\n      while ((group = queue.tree.first)) {\n        while ((op = group.activeChilds.tree.first)) {\n          if (now() - start >= TASK_DEADLINE) {\n            interrupted = true\n            endMark('tree')\n            break quant\n          }\n          op.runOp(op.value.pending)\n          op.value.active = op.value.pending\n          removeOpFromQueue(op)\n        }\n        removeOpGroupFromQueue(group, 'tree')\n      }\n      if (hasTreeTasks) endMark('tree')\n\n      const hasDataTasks = !!queue.data.first\n      if (hasDataTasks) beginMark('data')\n\n      while ((group = queue.data.first)) {\n        while ((op = group.activeChilds.data.first)) {\n          if (now() - start >= TASK_DEADLINE) {\n            interrupted = true\n            endMark('data')\n            break quant\n          }\n          op.runOp(op.value.pending)\n          op.value.active = op.value.pending\n          removeOpFromQueue(op)\n        }\n        removeOpGroupFromQueue(group, 'data')\n      }\n      if (hasDataTasks) endMark('data')\n    }\n  }\n  endMark('execQueue')\n  if (interrupted) {\n    queue.rafID = raf(queue.execQueue)\n  } else {\n    queue.rafID = null\n    if (queue.onDrain) {\n      const rs = queue.onDrain\n      queue.onDrain = null\n      rs()\n    }\n  }\n}\n\nexport function createOp({\n  value,\n  runOp,\n  group,\n  priority,\n}: {\n  value: any\n  runOp: (value: any) => void\n  group: OpGroup\n  priority: 'props' | 'tree' | 'data'\n}): Op {\n  return {\n    value: {\n      active: value,\n      pending: value,\n    },\n    runOp,\n    status: 'active',\n    priority,\n    group,\n    cursor: {\n      prev: null,\n      next: null,\n    },\n  }\n}\n\nexport function createOpQueue({\n  onComplete,\n}: {\n  onComplete?: () => void\n}): OpPriorityQueue {\n  const queue: OpPriorityQueue = {\n    props: {\n      first: null,\n      last: null,\n    },\n    tree: {\n      first: null,\n      last: null,\n    },\n    data: {\n      first: null,\n      last: null,\n    },\n    rafID: null,\n    execQueue() {},\n    onDrain: onComplete,\n  }\n  queue.execQueue = execQueue.bind(null, queue)\n  return queue\n}\n\nexport function createOpGroup(queue: OpPriorityQueue): OpGroup {\n  return {\n    ops: [],\n    queue,\n    activeChilds: {\n      props: {\n        first: null,\n        last: null,\n      },\n      tree: {\n        first: null,\n        last: null,\n      },\n      data: {\n        first: null,\n        last: null,\n      },\n    },\n    cursor: {\n      props: {\n        prev: null,\n        next: null,\n      },\n      tree: {\n        prev: null,\n        next: null,\n      },\n      data: {\n        prev: null,\n        next: null,\n      },\n    },\n  }\n}\n\nexport function createAsyncValue({\n  value,\n  group,\n  onInit,\n  onChange,\n}: {\n  value: any\n  group: OpGroup\n  onInit: (value: any) => void\n  onChange: (value: any) => void\n}): AsyncValue {\n  const change = createOp({\n    value,\n    group,\n    runOp(value) {\n      item.status = 'A'\n      onChange(value)\n    },\n    priority: 'data',\n  })\n  const item: AsyncValue = {\n    status: 'IA',\n    value: change.value,\n    ops: {\n      init: createOp({\n        value: false,\n        group,\n        runOp(value) {\n          item.status = 'A'\n          onInit(item.value.active)\n        },\n        priority: 'data',\n      }),\n      change,\n      terminate: createOp({\n        value: false,\n        group,\n        runOp(value) {\n          item.status = 'T'\n        },\n        priority: 'data',\n      }),\n    },\n  }\n  pushOpToQueue(true, item.ops.init)\n  return item\n}\n\nexport function stopAsyncValue(item: AsyncValue) {\n  switch (item.status) {\n    case 'I':\n    case 'T':\n    case 'AT':\n      return\n    case 'A':\n      item.status = 'AT'\n      pushOpToQueue(true, item.ops.terminate)\n      break\n    case 'AA':\n      item.status = 'AT'\n      pushOpToQueue(true, item.ops.terminate)\n      pushOpToQueue(item.value.active, item.ops.change)\n      break\n    case 'IA':\n      item.status = 'T'\n      pushOpToQueue(false, item.ops.init)\n      break\n  }\n}\n\nexport function updateAsyncValue(value: any, item: AsyncValue) {\n  switch (item.status) {\n    case 'I':\n    case 'T':\n      return\n    case 'A':\n      if (item.value.active !== value) {\n        item.status = 'AA'\n        pushOpToQueue(value, item.ops.change)\n      }\n      break\n    case 'AA':\n      if (item.value.active === value) {\n        item.status = 'A'\n        pushOpToQueue(value, item.ops.change)\n      } else if (item.value.pending !== value) {\n        item.value.pending = value\n      }\n      break\n    case 'IA':\n      item.value.active = item.value.pending = value\n      break\n    case 'AT':\n      // item.status = item.value.active === value ? 'A' : 'AA'\n      // pushOpToQueue(value, item.ops.change)\n      // pushOpToQueue(false, item.ops.terminate)\n      break\n  }\n}\n","export const USE_PERF = true\n\nexport const TASK_DEADLINE = 1000\n","import type {DOMElement, StaticOperationDef} from './index.h'\n\nconst defMap = {\n  attr: applyAttr,\n  data: applyDataAttr,\n  style: applyStyle,\n  styleVar: applyStyleVar,\n}\n\nexport function escapeTag(value: string) {\n  value = String(value)\n  switch (value) {\n    case '__proto__':\n    case '__defineGetter__':\n    case '__defineSetter__':\n    case 'constructor':\n    case 'prototype':\n    case 'hasOwnProperty':\n    case 'toString':\n    case 'valueOf':\n    case 'setProperty':\n    case 'removeProperty':\n      return 'forbidden'\n    default:\n      return value.replace(/[^a-zA-Z0-9\\-_]/g, '')\n  }\n}\n\nexport function applyStaticOps(\n  element: DOMElement,\n  defs: StaticOperationDef[],\n) {\n  for (let i = 0; i < defs.length; i++) {\n    const {type, field, value} = defs[i]\n    defMap[type](element, field, value)\n  }\n}\n\nexport function isFalse(val: any) {\n  return (\n    val !== '' &&\n    val !== 0 &&\n    val !== '0' &&\n    (val === false || val === undefined || val === null)\n  )\n}\n\nexport function applyStyleVar(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    element.style.removeProperty(`--${field}`)\n  } else {\n    element.style.setProperty(`--${field}`, `${value}`)\n  }\n}\n\nexport function applyStyle(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    delete element.style[field as any]\n  } else {\n    element.style[field as any] = `${value}`\n  }\n}\n\nexport function applyDataAttr(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    delete element.dataset[field]\n  } else {\n    element.dataset[field] = `${value}`\n  }\n}\nexport function applyAttr(\n  element: DOMElement,\n  field: string,\n  value: string | number | boolean | null,\n) {\n  if (isFalse(value)) {\n    switch (field) {\n      case 'value':\n        //@ts-expect-error\n        delete element.value\n        break\n      case 'checked':\n        //@ts-expect-error\n        element.checked = false\n        break\n      case 'spellcheck':\n        if (value === false) {\n          element.setAttribute('spellcheck', 'false')\n          return\n        }\n        break\n    }\n    element.removeAttribute(field)\n  } else {\n    switch (field) {\n      case 'value':\n        //@ts-expect-error\n        element.value = `${value}`\n        break\n      case 'checked':\n        //@ts-expect-error\n        element.checked = `${value}`\n        break\n    }\n    element.setAttribute(field, `${value}`)\n  }\n}\n\nexport function applyText(textNode: Text, text: string | number | boolean) {\n  textNode.replaceData(0, (textNode.textContent || '').length, String(text))\n}\n","import {\n  Store,\n  Event,\n  launch,\n  step,\n  createNode,\n  withRegion,\n  restore,\n  createEvent,\n} from 'effector'\nimport type {Scope} from '../effector/unit.h'\nimport type {StateRef} from '../effector/index.h'\nimport type {Stack} from '../effector/kernel'\nimport type {\n  Leaf,\n  NSType,\n  DOMElement,\n  LeafData,\n  Template,\n  NodeDraft,\n  Root,\n} from './index.h'\nimport type {OpGroup} from './plan/index.h'\nimport {handlers} from './templateHandlers'\n\nlet templateID = 0\nlet spawnID = 0\nexport let currentTemplate: Template | null = null\nexport let currentLeaf: Leaf | null = null\n\nexport function createTemplate<Api extends {[method: string]: any}>(config: {\n  fn: (\n    state: {\n      [field: string]: Store<any>\n    },\n    triggers: {\n      mount: Event<Leaf>\n    },\n  ) => {[K in keyof Api]: Event<Api[K]>}\n  state?: {[field: string]: any}\n  defer?: boolean\n  name: string\n  isSvgRoot: boolean\n  draft: NodeDraft\n  namespace: NSType\n  env: {\n    document: Document\n  }\n  isBlock?: boolean\n}): Template\n//@ts-expect-error\nexport function createTemplate(config: {\n  fn: (\n    state: {\n      [field: string]: Store<any>\n    },\n    triggers: {\n      mount: Event<Leaf>\n    },\n  ) => void\n  state?: {[field: string]: any}\n  defer?: boolean\n  name: string\n  isSvgRoot: boolean\n  draft: NodeDraft\n  namespace: NSType\n  env: {\n    document: Document\n  }\n  isBlock?: boolean\n}): Template\nexport function createTemplate<Api extends {[method: string]: any}>({\n  fn,\n  state: values = {},\n  defer = false,\n  name = '',\n  draft,\n  isSvgRoot,\n  namespace,\n  env,\n  isBlock = false,\n}: {\n  fn: (\n    state: {\n      [field: string]: Store<any>\n    },\n    triggers: {\n      mount: Event<Leaf>\n    },\n  ) => {[K in keyof Api]: Event<Api[K]>}\n  state?: {[field: string]: any}\n  defer?: boolean\n  name: string\n  isSvgRoot: boolean\n  draft: NodeDraft\n  namespace: NSType\n  env: {\n    document: Document\n  }\n  isBlock?: boolean\n}): Template {\n  const parent = currentTemplate\n  const template: Template = {\n    id: ++templateID,\n    name,\n    plain: [],\n    watch: [],\n    nameMap: {},\n    pages: [],\n    closure: [],\n    childTemplates: [],\n    handlers,\n    upward: step.filter({\n      //@ts-expect-error\n      fn(upd, scope, stack: Stack) {\n        if (!stack.page) {\n          if (stack.parent && stack.parent.page) {\n            stack.page = stack.parent.page\n          } else {\n            // console.error('context lost', stack)\n            return true\n          }\n        }\n        if (!stack.page.root.activeSpawns.has(stack.page.fullID)) {\n          console.count('inactive page upward')\n          return false\n        }\n        const stackTemplates = [stack.page.template]\n        const stackPages = [stack.page]\n        {\n          let currentStackPage = stack.page.parent\n          while (currentStackPage) {\n            stackPages.push(currentStackPage)\n            stackTemplates.push(currentStackPage.template)\n            currentStackPage = currentStackPage.parent\n          }\n        }\n        stack.node.next.forEach(node => {\n          /**\n           * node.meta.nativeTemplate is used in units\n           * it represents template in which unit was created (belongs to)\n           */\n          const targetTemplate: Template | void = node.meta.nativeTemplate\n          if (targetTemplate) {\n            if (stackTemplates.includes(targetTemplate)) {\n              const page = stackPages[stackTemplates.indexOf(targetTemplate)]\n              launch({\n                //@ts-expect-error\n                target: node,\n                params: upd,\n                defer: true,\n                page,\n                stack,\n                //@ts-expect-error\n                scope: stack.scope,\n              })\n            } else {\n              console.error('context drift', {stack, node})\n            }\n          } else {\n            launch({\n              //@ts-expect-error\n              target: node,\n              params: upd,\n              defer: true,\n              page: stack.page,\n              stack,\n              //@ts-expect-error\n              scope: stack.scope,\n            })\n          }\n        })\n        return false\n      },\n    }),\n    loader: step.filter({\n      //@ts-expect-error\n      fn(upd, scope, stack: Stack) {\n        if (stack.parent) {\n          const forkId = stack.scope ? stack.scope.graphite.id : null\n          if (stack.page) {\n            if (!stack.page.root.activeSpawns.has(stack.page.fullID)) {\n              console.count('inactive page loader')\n              return false\n            }\n            if (stack.page.template === template) {\n              return true\n            }\n\n            if (stack.page.root.childSpawns[stack.page.fullID][template.id]) {\n              const fullID = stack.page!.fullID\n              stack.page.root.childSpawns[fullID][template.id].forEach(page => {\n                if (forkId) {\n                  if (\n                    !page.root.scope ||\n                    forkId !== page.root.scope.graphite.id\n                  )\n                    return\n                }\n                launch({\n                  params: upd,\n                  //@ts-expect-error\n                  target: stack.node,\n                  page,\n                  defer: true,\n                  //@ts-expect-error\n                  scope: stack.scope,\n                })\n              })\n            } else {\n              const fullID = stack.page.fullID\n              const isRecTemplate = stack.page.template.name === 'rec'\n\n              template.pages.forEach(page => {\n                if (forkId) {\n                  if (\n                    !page.root.scope ||\n                    forkId !== page.root.scope.graphite.id\n                  )\n                    return\n                }\n                if (\n                  page.fullID === fullID ||\n                  page.fullID.startsWith(`${fullID}_`)\n                ) {\n                  let validTarget = true\n                  if (isRecTemplate) {\n                    const recID = stack.page!.template.id\n                    let parentPage = page.parent\n                    while (parentPage) {\n                      if (parentPage === stack.page) {\n                        break\n                      }\n                      if (parentPage.template.id === recID) {\n                        validTarget = false\n                        break\n                      }\n                      parentPage = parentPage.parent\n                    }\n                  }\n                  if (validTarget) {\n                    launch({\n                      params: upd,\n                      //@ts-expect-error\n                      target: stack.node,\n                      page,\n                      defer: true,\n                      //@ts-expect-error\n                      scope: stack.scope,\n                    })\n                  }\n                } else {\n                  if (fullID.startsWith(`${page.fullID}_`)) {\n                    launch({\n                      params: upd,\n                      //@ts-expect-error\n                      target: stack.node,\n                      page: stack.page,\n                      defer: true,\n                      //@ts-expect-error\n                      scope: stack.scope,\n                    })\n                  } else {\n                    // console.count('no page match')\n                  }\n                }\n              })\n            }\n          } else {\n            template.pages.forEach(page => {\n              if (forkId) {\n                if (!page.root.scope || forkId !== page.root.scope.graphite.id)\n                  return\n              }\n              launch({\n                params: upd,\n                //@ts-expect-error\n                target: stack.node,\n                page,\n                defer: true,\n                //@ts-expect-error\n                scope: stack.scope,\n              })\n            })\n          }\n          return false\n        }\n        return true\n      },\n    }),\n    parent,\n    node: null as any,\n    api: null as any,\n    trigger: {\n      //@ts-expect-error\n      mount: createEvent<Leaf>({named: 'mount'}),\n    },\n    draft,\n    isSvgRoot,\n    namespace,\n    env,\n    isBlock: isBlock || !!(parent && parent.isBlock),\n  }\n  if (parent) {\n    parent.childTemplates.push(template)\n  }\n  const node = createNode({\n    meta: {\n      template,\n    },\n  })\n  template.node = node\n  currentTemplate = template\n  if (!defer) {\n    withRegion(node, () => {\n      const state = restore(values)\n      template.api = fn(state, template.trigger)\n      template.nameMap = state\n    })\n  } else {\n    template.deferredInit = () => {\n      const prevTemplate = currentTemplate\n      currentTemplate = template\n      template.deferredInit = null\n      try {\n        withRegion(node, () => {\n          const state = restore(values)\n          template.api = fn(state, template.trigger)\n          template.nameMap = state\n        })\n      } finally {\n        currentTemplate = prevTemplate\n      }\n    }\n  }\n  currentTemplate = parent\n  return template\n}\n\nfunction getCurrent(ref: StateRef, forkPage?: Scope) {\n  let result\n  if (forkPage) result = forkPage.getState(ref)\n  else result = ref.current\n  switch (ref.type) {\n    case 'list':\n      return [...result]\n    case 'shape':\n      return {...result}\n    default:\n      return result\n  }\n}\nfunction findRef(\n  ref: StateRef,\n  targetLeaf: Leaf | null,\n  forkPage?: Scope,\n): StateRef {\n  let currentLeaf = targetLeaf\n  while (currentLeaf && !regRef(currentLeaf, ref)) {\n    currentLeaf = currentLeaf.parent\n  }\n  if (!currentLeaf) {\n    if (forkPage) {\n      forkPage.getState(ref)\n      return forkPage.reg[ref.id]\n    }\n    return ref\n  }\n  return regRef(currentLeaf, ref)\n}\nfunction findRefValue(\n  ref: StateRef,\n  targetLeaf: Leaf | null,\n  forkPage?: Scope,\n) {\n  return findRef(ref, targetLeaf, forkPage).current\n}\nfunction ensureLeafHasRef(ref: StateRef, leaf: Leaf) {\n  if (!regRef(leaf, ref)) {\n    leaf.reg[ref.id] = findRef(ref, leaf.parent, leaf.root.scope)\n  }\n}\nconst regRef = (page: {reg: Record<string, StateRef>}, ref: StateRef) =>\n  page.reg[ref.id]\nfunction addMapItems<T>(\n  values: T[],\n  id: string | number,\n  record: Record<string | number, T[]>,\n) {\n  if (!(id in record)) {\n    record[id] = []\n  }\n  record[id].push(...values)\n}\nexport function spawn(\n  template: Template,\n  {\n    values = {},\n    parentLeaf,\n    mountNode,\n    svgRoot,\n    leafData,\n    opGroup,\n    domSubtree,\n    hydration,\n    root,\n  }: {\n    values?: {[field: string]: any}\n    parentLeaf: Leaf | null\n    mountNode: DOMElement\n    svgRoot: SVGSVGElement | null\n    leafData: LeafData\n    opGroup: OpGroup\n    domSubtree: OpGroup\n    hydration: boolean\n    root: Root\n  },\n): Leaf {\n  const page = {} as Record<string, StateRef>\n\n  const leaf: Leaf = {\n    draft: template.draft,\n    svgRoot,\n    data: leafData,\n    parent: parentLeaf,\n    hydration,\n    mountNode,\n    root,\n    id: ++spawnID,\n    fullID: '',\n    reg: page,\n    template,\n  }\n  template.pages.push(leaf)\n  const previousSpawn = currentLeaf\n  currentLeaf = leaf\n  if (parentLeaf) {\n    addMapItems([leaf], template.id, root.childSpawns[parentLeaf.fullID])\n  }\n  if (parentLeaf) {\n    leaf.fullID = `${parentLeaf.fullID}_${leaf.id}`\n  } else {\n    leaf.fullID = `${leaf.id}`\n  }\n  root.childSpawns[leaf.fullID] = {}\n  root.activeSpawns.add(leaf.fullID)\n  root.leafOps[leaf.fullID] = {group: opGroup, domSubtree}\n  for (let i = 0; i < template.closure.length; i++) {\n    const ref = template.closure[i]\n    let closureRef = ref\n    let parent = leaf.parent\n    findClosure: while (parent) {\n      if (regRef(parent, ref)) {\n        closureRef = regRef(parent, ref)\n        break findClosure\n      }\n      parent = parent.parent\n    }\n    if (!parent && root.scope) {\n      root.scope.getState(ref)\n      closureRef = root.scope.reg[ref.id]\n    }\n    page[ref.id] = closureRef\n  }\n\n  for (let i = 0; i < template.plain.length; i++) {\n    const ref = template.plain[i]\n    const next: StateRef = {\n      id: ref.id,\n      current: getCurrent(ref, root.scope),\n    }\n    page[ref.id] = next\n  }\n  for (const name in values) {\n    const id = template.nameMap[name].stateRef.id\n    page[id] = {\n      id,\n      current: values[name],\n    }\n  }\n  function execRef(ref: StateRef) {\n    if (ref.before) {\n      for (let i = 0; i < ref.before.length; i++) {\n        const cmd = ref.before[i]\n        switch (cmd.type) {\n          case 'map': {\n            const from = cmd.from\n            if (!cmd.fn && !from) break\n            let value\n            if (from) {\n              ensureLeafHasRef(from, leaf)\n              value = page[from.id].current\n            }\n            page[ref.id].current = cmd.fn ? cmd.fn(value) : value\n            break\n          }\n          case 'field': {\n            const from = cmd.from\n            ensureLeafHasRef(from, leaf)\n            page[ref.id].current[cmd.field] = page[from.id].current\n            break\n          }\n          case 'closure':\n            ensureLeafHasRef(cmd.of, leaf)\n            break\n        }\n      }\n    }\n  }\n  template.closure.forEach(execRef)\n  template.plain.forEach(execRef)\n\n  function runWatchersFrom(\n    list: any[],\n    state: {i: number; stop: boolean},\n    page: Record<string, StateRef>,\n  ) {\n    state.stop = true\n    let val\n    try {\n      while (state.i < list.length) {\n        val = list[state.i]\n        state.i++\n        val.fn(\n          page[val.of.id]\n            ? page[val.of.id].current\n            : findRefValue(val.of, leaf.parent, leaf.root.scope),\n        )\n      }\n    } catch (err) {\n      console.error(err)\n      state.stop = false\n    }\n  }\n  const state = {i: 0, stop: false}\n  while (!state.stop) {\n    runWatchersFrom(template.watch, state, page)\n  }\n  if (parentLeaf) {\n    for (const id in root.childSpawns[leaf.fullID]) {\n      addMapItems(\n        root.childSpawns[leaf.fullID][id],\n        id,\n        root.childSpawns[parentLeaf.fullID],\n      )\n    }\n  }\n  if (mountQueue) {\n    mountQueue.steps.push({\n      target: template.trigger.mount,\n      params: leaf,\n      defer: true,\n      page: leaf,\n      scope: root.scope,\n    })\n  } else {\n    mountQueue = {\n      parent: mountQueue,\n      steps: [\n        {\n          target: template.trigger.mount,\n          params: leaf,\n          defer: true,\n          page: leaf,\n          scope: root.scope,\n        },\n      ],\n    }\n    let step: any\n    do {\n      while ((step = mountQueue.steps.shift())) {\n        mountQueue = {\n          parent: mountQueue,\n          steps: [],\n        }\n        launch(step)\n      }\n    } while ((mountQueue = mountQueue.parent))\n  }\n  currentLeaf = previousSpawn\n  return leaf\n}\n\ntype MountQueue = {\n  parent: MountQueue | null\n  steps: any[]\n}\n\nlet mountQueue: MountQueue | null = null\n","import type {DOMElement} from './index.h'\n\nimport type {\n  ElementBlock,\n  TextBlock,\n  UsingBlock,\n  Block,\n  BlockBlock,\n} from './relation.h'\n\nexport function findParentDOMElement(\n  block: Exclude<Block, UsingBlock | BlockBlock>,\n): DOMElement | null {\n  let parent = block.parent\n  while (parent.type !== 'element' && parent.type !== 'using') {\n    parent = parent.parent\n  }\n  if (parent) return parent.value\n  return null\n}\nfunction findLastVisibleChildBlock(\n  block: Exclude<Block, UsingBlock>,\n): ElementBlock | TextBlock | null {\n  if (!block.visible) return null\n  switch (block.type) {\n    case 'text':\n    case 'element':\n      return block\n    case 'LF':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem': {\n      for (let i = block.child.length - 1; i >= 0; i--) {\n        const child = block.child[i]\n        const visibleChild = findLastVisibleChildBlock(child)\n        if (visibleChild) return visibleChild\n      }\n      return null\n    }\n    case 'list': {\n      let child = block.lastChild\n      if (!child) return null\n      while (child) {\n        const visibleChild = findLastVisibleChildBlock(child)\n        if (visibleChild) return visibleChild\n        child = child.left\n      }\n      return null\n    }\n    default: {\n      const _: never = block\n      return null\n    }\n  }\n}\n\nexport function findPreviousVisibleSiblingBlock(\n  block: Block,\n): TextBlock | ElementBlock | null {\n  switch (block.type) {\n    case 'using':\n      return null\n    case 'LF': {\n      let sibling = block.left\n      while (sibling) {\n        const visibleChild = findLastVisibleChildBlock(sibling)\n        if (visibleChild) return visibleChild\n        sibling = sibling.left\n      }\n      return findPreviousVisibleSiblingBlock(block.parent)\n    }\n    case 'element':\n    case 'text':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n    case 'list': {\n      const parentFragment = block.parent\n      for (let i = block.index - 1; i >= 0; i--) {\n        const sibling = parentFragment.child[i]\n        if (!sibling) continue\n        const visibleChild = findLastVisibleChildBlock(sibling)\n        if (visibleChild) return visibleChild\n      }\n      switch (parentFragment.type) {\n        case 'element':\n        case 'using':\n          return null\n      }\n      return findPreviousVisibleSiblingBlock(parentFragment)\n    }\n    default: {\n      const _: never = block\n      return null\n    }\n  }\n}\n\nexport function findPreviousVisibleSibling(\n  block: Exclude<Block, UsingBlock>,\n): DOMElement | Text | null {\n  const child = findPreviousVisibleSiblingBlock(block)\n  if (child) return child.value\n  return null\n}\n","export function assert(condition: any, msg: string): asserts condition {\n  if (!condition) throw Error(msg)\n}\n\nexport function assertClosure(\n  currentActor: any,\n  methodName: string,\n): asserts currentActor {\n  if (!currentActor)\n    throw Error(`${methodName}() called outside from using() closure`)\n}\n","import {launch, createEvent} from 'effector'\n\nimport type {\n  DOMElement,\n  Leaf,\n  BindingsDraft,\n  LeafData,\n  Env,\n  LeafDataElement,\n  Template,\n} from './index.h'\n\nimport type {\n  ElementBlock,\n  ListBlock,\n  TextBlock,\n  RouteBlock,\n  FragmentParent,\n  RecItemBlock,\n  RecBlock,\n  BlockBlock,\n  BlockItemBlock,\n} from './relation.h'\n\nimport {createOpGroup, createOp} from './plan'\n\nimport {spawn, currentTemplate} from './template'\nimport {findParentDOMElement, findPreviousVisibleSibling} from './search'\nimport {applyStaticOps} from './bindings'\nimport {assert} from './assert'\n\nexport function setInParentIndex(template: Template) {\n  if (!currentTemplate) return\n  const {draft} = template\n  if (draft.type === 'listItem') return\n  if (draft.type === 'rec') return\n  switch (currentTemplate.draft.type) {\n    case 'element':\n    case 'using':\n    case 'route':\n    case 'list':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n      draft.inParentIndex = currentTemplate.draft.childCount\n      currentTemplate.draft.childCount += 1\n      currentTemplate.draft.childTemplates.push(template)\n      break\n    default:\n      console.warn(\n        `unexpected currentTemplate type ${currentTemplate.draft.type}`,\n      )\n  }\n}\n\nexport function mountChildTemplates(\n  draft: BindingsDraft,\n  {\n    parentBlockFragment,\n    leaf,\n    node,\n    svgRoot,\n    values,\n  }: {\n    parentBlockFragment: FragmentParent\n    leaf: Leaf\n    node?: DOMElement\n    svgRoot?: SVGSVGElement | null\n    values?: {[name: string]: any}\n  },\n) {\n  draft.childTemplates.forEach(actor => {\n    mountChild({\n      parentBlockFragment,\n      leaf,\n      node,\n      svgRoot,\n      values,\n      actor,\n    })\n  })\n}\nconst fragmentParentTypes: Array<FragmentParent['type']> = [\n  'LF',\n  'using',\n  'element',\n  'recItem',\n  'rec',\n  'block',\n  'blockItem',\n  'route',\n]\n\nexport function mountChild({\n  parentBlockFragment,\n  leaf,\n  node = leaf.mountNode,\n  actor,\n  svgRoot,\n  values,\n}: {\n  parentBlockFragment: FragmentParent\n  leaf: Leaf\n  node?: DOMElement\n  actor: Template\n  svgRoot?: SVGSVGElement | null\n  values?: {[name: string]: any}\n}) {\n  assert(\n    fragmentParentTypes.includes(parentBlockFragment.type),\n    `incorrect parent ${parentBlockFragment.type}`,\n  )\n  let leafData: LeafData\n  const {draft} = actor\n  const {queue} = leaf.root.leafOps[leaf.fullID].group\n  const opGroup = createOpGroup(queue)\n  const parentDomSubtree = leaf.root.leafOps[leaf.fullID].domSubtree\n  let domSubtree = parentDomSubtree\n  switch (draft.type) {\n    case 'route': {\n      const routeBlock: RouteBlock = {\n        type: 'route',\n        parent: parentBlockFragment,\n        child: [],\n        visible: false,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = routeBlock\n      leafData = {\n        type: 'route',\n        block: routeBlock,\n        ops: {},\n        initialized: false,\n        pendingInit: null,\n      }\n      break\n    }\n    case 'element': {\n      let element: DOMElement\n      if (actor.isBlock) {\n        let env: Env | void\n        let type: 'html' | 'svg' | void\n        let currentLeaf = leaf\n        while (currentLeaf && (!type || !env)) {\n          if (currentLeaf.template.env) env = currentLeaf.template.env\n          const {draft} = currentLeaf\n          if (draft.type === 'element') {\n            if (draft.tag === 'svg') {\n              type = 'svg'\n            } else if (draft.tag === 'foreignObject') {\n              type = 'html'\n            }\n          }\n          currentLeaf = currentLeaf.parent!\n        }\n        if (!type) type = 'html'\n        if (env) {\n          element =\n            type === 'svg'\n              ? env.document.createElementNS(\n                  'http://www.w3.org/2000/svg',\n                  draft.tag,\n                )\n              : env.document.createElement(draft.tag)\n          applyStaticOps(element, draft.staticSeq)\n        }\n      } else {\n        element = draft.stencil.cloneNode() as DOMElement\n      }\n      const elementBlock: ElementBlock = {\n        type: 'element',\n        parent: parentBlockFragment,\n        child: [],\n        value: element!,\n        visible: false,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = elementBlock\n      leafData = {\n        type: 'element',\n        block: elementBlock,\n        ops: {\n          visible: createOp({\n            value: false,\n            priority: 'tree',\n            runOp(value) {\n              if (leaf.hydration) {\n              }\n              if (value) {\n                appendChild(elementBlock)\n                const leafData_ = leafData as LeafDataElement\n                if (leafData_.needToCallNode) {\n                  leafData_.needToCallNode = false\n                  launch({\n                    target: onMount,\n                    params: {\n                      element: elementBlock.value,\n                      fns: draft.node,\n                    },\n                    page: childSpawn,\n                    //@ts-expect-error\n                    scope: leaf.root.scope,\n                  })\n                }\n                elementBlock.visible = true\n              } else {\n                elementBlock.value.remove()\n                elementBlock.visible = false\n              }\n            },\n            group: parentDomSubtree,\n          }),\n        },\n        needToCallNode: draft.node.length > 0,\n      }\n      domSubtree = createOpGroup(queue)\n      break\n    }\n    case 'list': {\n      const listBlock: ListBlock = {\n        type: 'list',\n        parent: parentBlockFragment,\n        child: [],\n        lastChild: null,\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = listBlock\n      leafData = {\n        type: 'list',\n        draft,\n        block: listBlock,\n        records: [],\n        pendingUpdate: null,\n      }\n      break\n    }\n    case 'using':\n    case 'listItem':\n      break\n    case 'rec': {\n      const recBlock: RecBlock = {\n        type: 'rec',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = recBlock\n      leafData = {\n        type: 'rec',\n        block: recBlock,\n      }\n      break\n    }\n    case 'recItem': {\n      const recItemBlock: RecItemBlock = {\n        type: 'recItem',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = recItemBlock\n      leafData = {\n        type: 'rec item',\n        block: recItemBlock,\n      }\n      break\n    }\n    case 'block': {\n      const block: BlockBlock = {\n        type: 'block',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = block\n      leafData = {\n        type: 'block',\n        block,\n      }\n      break\n    }\n    case 'blockItem': {\n      const block: BlockItemBlock = {\n        type: 'blockItem',\n        parent: parentBlockFragment,\n        child: [],\n        visible: true,\n        index: draft.inParentIndex,\n      }\n      parentBlockFragment.child[draft.inParentIndex] = block\n      leafData = {\n        type: 'block item',\n        block: block,\n      }\n      break\n    }\n    default: {\n      //@ts-expect-error\n      console.warn(`unexpected draft type ${draft.type}`)\n    }\n  }\n  const childSpawn = spawn(actor, {\n    values,\n    parentLeaf: leaf,\n    mountNode: node,\n    svgRoot: svgRoot ? svgRoot : leaf.svgRoot,\n    //@ts-expect-error\n    leafData,\n    opGroup,\n    domSubtree,\n    hydration: leaf.hydration,\n    root: leaf.root,\n  })\n}\n\nexport function appendChild(block: TextBlock | ElementBlock) {\n  const visibleSibling = findPreviousVisibleSibling(block)\n  if (visibleSibling) {\n    visibleSibling.after(block.value)\n  } else {\n    const parent = findParentDOMElement(block)\n    parent!.prepend(block.value)\n  }\n  block.visible = true\n}\n\n//@ts-expect-error\nexport const onMount = createEvent<{\n  fns: Array<(node: DOMElement) => (() => void) | void>\n  element: DOMElement\n}>({named: 'onMount'})\n\nonMount.watch(({fns, element}) => {\n  fns.forEach(fn => {\n    fn(element)\n  })\n})\n","import {Store, Event, sample} from 'effector'\n\nexport function mutualSample<Mount, State, T>({\n  mount,\n  state,\n  onMount,\n  onState,\n}: {\n  mount: Event<Mount>\n  state: Store<State>\n  onMount: (state: State, mount: Mount) => T\n  onState: (mount: Mount, state: State) => T\n}): {\n  onMount: Event<T>\n  onState: Event<T>\n} {\n  return {\n    onMount: sample({\n      source: state,\n      clock: mount,\n      fn: onMount,\n      greedy: true,\n    }),\n    onState: sample({\n      source: mount,\n      clock: state,\n      fn: onState,\n      greedy: true,\n    }),\n  }\n}\n","export function forIn<T extends Record<string, unknown>>(\n  obj: T,\n  cb: (value: T[keyof T], key: Exclude<keyof T, number>) => void,\n) {\n  for (const key in obj) {\n    cb(obj[key], key as any)\n  }\n}\n","import {Event, is} from 'effector'\n\nimport {currentTemplate} from '../template'\nimport {assert} from '../assert'\n\nexport function handler(\n  map: Partial<\n    {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n  >,\n): void\nexport function handler(\n  options: {\n    passive?: boolean\n    capture?: boolean\n    prevent?: boolean\n    stop?: boolean\n  },\n  map: Partial<\n    {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n  >,\n): void\nexport function handler(options: any, map?: any) {\n  if (!currentTemplate) return\n  const draft = currentTemplate.draft\n  assert(\n    draft.type === 'element',\n    `\"handler\" extension can be used only with element nodes, got \"${draft.type}\"`,\n  )\n  if (map === undefined) {\n    map = options\n    options = {}\n  }\n  for (const key in map) {\n    assert(is.unit(map[key]), `handler for \"${key}\" should be event`)\n  }\n  const {\n    passive = false,\n    capture = false,\n    prevent = false,\n    stop = false,\n  } = options\n  draft.handler.push({\n    options: {\n      prevent,\n      stop,\n    },\n    domConfig: {\n      passive: prevent ? false : passive,\n      capture,\n    },\n    map,\n  })\n}\n","import type {Store, Event} from 'effector'\n\nimport type {\n  PropertyMap,\n  StoreOrData,\n  DOMProperty,\n  StylePropertyMap,\n} from '../index.h'\n\nimport {escapeTag} from '../bindings'\nimport {currentTemplate} from '../template'\nimport {assertClosure} from '../assert'\nimport {handler} from './handler'\n\nexport function spec(config: {\n  attr?: PropertyMap\n  data?: PropertyMap\n  text?: StoreOrData<DOMProperty> | Array<StoreOrData<DOMProperty>>\n  style?: StylePropertyMap\n  styleVar?: PropertyMap\n  visible?: Store<boolean>\n  handler?:\n    | {\n        config?: {\n          passive?: boolean\n          capture?: boolean\n          prevent?: boolean\n          stop?: boolean\n        }\n        on: Partial<\n          {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n        >\n      }\n    | Partial<{[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}>\n  ɔ?: any\n}) {\n  assertClosure(currentTemplate, 'spec')\n  const draft = currentTemplate.draft\n  switch (draft.type) {\n    case 'list':\n      if (config.visible) draft.itemVisible = config.visible\n      return\n    case 'listItem':\n    case 'using':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n      return\n  }\n  if (config.attr) draft.attr.push(config.attr)\n  if (config.data) draft.data.push(config.data)\n  if ('text' in config) {\n    const text = config.text\n    const firstIndex = draft.childCount\n    if (Array.isArray(text)) {\n      draft.text.push(\n        ...text.map((value, i) => ({\n          index: i + firstIndex,\n          value,\n        })),\n      )\n      draft.childCount += text.length\n    } else {\n      draft.text.push({\n        index: firstIndex,\n        value: text!,\n      })\n      draft.childCount += 1\n    }\n  }\n  if (config.style) {\n    const escaped = {} as StylePropertyMap\n    for (const field in config.style) {\n      //@ts-expect-error\n      escaped[escapeTag(field)] = config.style[field]\n    }\n    draft.style.push(escaped)\n  }\n  if (config.styleVar) draft.styleVar.push(config.styleVar)\n  if (config.visible) draft.visible = config.visible\n  if (config.handler) {\n    const handlerDef = config.handler\n    //@ts-expect-error\n    if (typeof handlerDef.on === 'object') {\n      //@ts-expect-error\n      handler(handlerDef.config || {}, handlerDef.on)\n    } else {\n      //@ts-expect-error\n      handler(handlerDef)\n    }\n  }\n  if (config.ɔ) {\n    spec(config.ɔ)\n  }\n}\n","import {Store, Event, is, launch, createEvent, sample, merge} from 'effector'\n\nimport type {StateRef} from '../../effector/index.h'\n\nimport type {\n  DOMElement,\n  ElementDraft,\n  NSType,\n  PropertyMap,\n  StoreOrData,\n  DOMProperty,\n  StylePropertyMap,\n  Leaf,\n  LeafDataElement,\n  Template,\n  HandlerRecord,\n  PropertyOperationDef,\n  PropertyOperationKind,\n} from '../index.h'\n\nimport type {ElementBlock, TextBlock} from '../relation.h'\n\nimport {pushOpToQueue, forceSetOpValue, createOp} from '../plan'\n\nimport {\n  applyStyle,\n  applyStyleVar,\n  applyDataAttr,\n  applyAttr,\n  applyText,\n  applyStaticOps,\n} from '../bindings'\nimport {createTemplate, currentTemplate} from '../template'\nimport {\n  findParentDOMElement,\n  findPreviousVisibleSibling,\n  findPreviousVisibleSiblingBlock,\n} from '../search'\nimport {\n  appendChild,\n  onMount as onMountSync,\n  mountChildTemplates,\n  setInParentIndex,\n} from '../mountChild'\nimport {assertClosure} from '../assert'\nimport {mutualSample} from '../mutualSample'\nimport {forIn} from '../forIn'\nimport {spec} from './spec'\n\nfunction createPropsOp<T, S>(\n  draft: ElementDraft,\n  {\n    initCtx,\n    runOp,\n    hooks: {onMount, onState},\n  }: {\n    initCtx(value: T, leaf: Leaf): S\n    runOp(value: T, ctx: S): void\n    hooks: {\n      onMount: Event<{leaf: Leaf; value: T}>\n      onState: Event<{leaf: Leaf; value: T}>\n    }\n  },\n) {\n  const opID = draft.opsAmount++\n  onMount.watch(({value, leaf}) => {\n    const op = createOp({\n      value,\n      priority: 'props',\n      runOp(value) {\n        runOp(value, ctx)\n      },\n      group: leaf.root.leafOps[leaf.fullID].group,\n    })\n    leaf.root.leafOps[leaf.fullID].group.ops[opID] = op\n    const ctx = initCtx(value, leaf)\n  })\n  onState.watch(({value, leaf}) => {\n    pushOpToQueue(value, leaf.root.leafOps[leaf.fullID].group.ops[opID])\n  })\n}\n\nconst syncOperations: Array<{\n  field: string\n  type: PropertyOperationKind\n}> = [\n  {type: 'attr', field: 'value'},\n  {type: 'attr', field: 'checked'},\n  {type: 'attr', field: 'min'},\n  {type: 'attr', field: 'max'},\n]\n\nconst propertyOperationBinding: Record<\n  PropertyOperationKind,\n  (\n    element: DOMElement,\n    field: string,\n    value: string | number | boolean | null,\n  ) => void\n> = {\n  attr: applyAttr,\n  data: applyDataAttr,\n  style: applyStyle,\n  styleVar: applyStyleVar,\n}\n\nconst readElement = (leaf: Leaf) => (leaf.data as LeafDataElement).block.value\n\n/** operation family for things represented as <el \"thing\"=\"value\" /> */\nfunction propertyMapToOpDef(\n  draft: ElementDraft,\n  type: PropertyOperationKind,\n  ops: {\n    attr: PropertyMap\n    data: PropertyMap\n    style: StylePropertyMap\n    styleVar: PropertyMap\n  },\n) {\n  draft[type].forEach(record => {\n    forIn(record as unknown as PropertyMap, (value, key) => {\n      switch (type) {\n        case 'data':\n        case 'styleVar':\n          ops[type][key] = value\n          break\n        case 'attr':\n          ops.attr[key === 'xlink:href' ? 'href' : key] = value\n          break\n        case 'style':\n          if (key.startsWith('--')) {\n            ops.styleVar[key.slice(2)] = value\n          } else {\n            //@ts-expect-error inconsistency in StylePropertyMap key type\n            ops.style[key] = value\n          }\n          break\n      }\n    })\n  })\n}\n\nfunction installTextNode(leaf: Leaf, value: string, childIndex: number) {\n  const parentBlock = leaf.data.block as ElementBlock\n  const textBlock: TextBlock = {\n    type: 'text',\n    parent: parentBlock,\n    visible: false,\n    index: childIndex,\n    //@ts-expect-error\n    value: null,\n  }\n  parentBlock.child[childIndex] = textBlock\n  if (leaf.hydration) {\n    const siblingBlock = findPreviousVisibleSiblingBlock(textBlock)\n    if (siblingBlock) {\n      switch (siblingBlock.type) {\n        case 'text': {\n          textBlock.value = leaf.root.env.document.createTextNode(value)\n          siblingBlock.value.after(textBlock.value)\n          break\n        }\n        case 'element': {\n          textBlock.value = siblingBlock.value.nextSibling! as Text\n          applyText(textBlock.value, value)\n          break\n        }\n      }\n    } else {\n      const parentElement = findParentDOMElement(textBlock)\n      textBlock.value = parentElement!.firstChild! as Text\n      applyText(textBlock.value, value)\n    }\n    textBlock.visible = true\n  } else {\n    textBlock.value = leaf.root.env.document.createTextNode(value)\n    appendChild(textBlock)\n  }\n  return textBlock\n}\n\nfunction processStoreRef(store: Store<any>) {\n  //@ts-expect-error\n  const ref: StateRef = store.stateRef\n  const templ: Template = currentTemplate!\n  if (!templ.plain.includes(ref) && !templ.closure.includes(ref)) {\n    templ.closure.push(ref)\n  }\n}\nexport function h(tag: string): void\nexport function h(tag: string, cb: () => void): void\nexport function h(\n  tag: string,\n  spec: {\n    fn?: () => void\n    attr?: PropertyMap\n    data?: PropertyMap\n    text?: StoreOrData<DOMProperty> | Array<StoreOrData<DOMProperty>>\n    visible?: Store<boolean>\n    style?: StylePropertyMap\n    styleVar?: PropertyMap\n    handler?:\n      | {\n          config?: {\n            passive?: boolean\n            capture?: boolean\n            prevent?: boolean\n            stop?: boolean\n          }\n          on: Partial<\n            {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n          >\n        }\n      | Partial<\n          {[K in keyof HTMLElementEventMap]: Event<HTMLElementEventMap[K]>}\n        >\n  },\n): void\nexport function h(tag: string, opts?: any) {\n  let hasCb = false\n  let hasOpts = false\n  let cb: () => void\n  if (typeof opts === 'function') {\n    hasCb = true\n    cb = opts\n  } else {\n    if (opts) {\n      hasOpts = true\n      if (opts.fn) {\n        hasCb = true\n        cb = opts.fn\n      }\n      if (opts.ɔ) {\n        if (typeof opts.ɔ === 'function') {\n          hasCb = true\n          cb = opts.ɔ\n        } else if (typeof opts.ɔ.fn === 'function') {\n          hasCb = true\n          cb = opts.ɔ.fn\n        }\n      }\n    }\n  }\n  assertClosure(currentTemplate, 'h')\n  const env = currentTemplate.env\n  const parentNS = currentTemplate.namespace\n  let ns: NSType = parentNS\n  let type = 'html'\n  ns = type = parentNS === 'svg' ? 'svg' : 'html'\n  if (tag === 'svg') {\n    type = 'svg'\n    ns = 'svg'\n  }\n  let node: DOMElement\n  if (!currentTemplate.isBlock) {\n    node =\n      type === 'svg'\n        ? env.document.createElementNS('http://www.w3.org/2000/svg', tag)\n        : env.document.createElement(tag)\n  }\n  const stencil = node!\n  const draft: ElementDraft = {\n    type: 'element',\n    tag,\n    attr: [],\n    data: [],\n    text: [],\n    style: [],\n    styleVar: [],\n    handler: [],\n    stencil,\n    seq: [],\n    staticSeq: [],\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n    opsAmount: 1,\n    node: [],\n  }\n  if (parentNS === 'foreignObject') {\n    draft.attr.push({\n      xmlns: 'http://www.w3.org/1999/xhtml',\n    })\n    ns = 'html'\n  } else if (tag === 'svg') {\n    draft.attr.push({\n      xmlns: 'http://www.w3.org/2000/svg',\n    })\n    ns = 'svg'\n  } else if (tag === 'foreignObject') {\n    ns = 'foreignObject'\n  }\n\n  const elementTemplate = createTemplate({\n    name: 'element',\n    draft,\n    isSvgRoot: tag === 'svg',\n    namespace: ns,\n    fn(_, {mount}) {\n      //@ts-expect-error\n      const domElementCreated = createEvent<Leaf>({named: 'domElementCreated'})\n\n      if (hasCb) {\n        cb()\n      }\n      if (hasOpts) {\n        spec(opts)\n      }\n      if (is.unit(draft.visible)) {\n        draft.seq.push({type: 'visible', value: draft.visible})\n        processStoreRef(draft.visible)\n      }\n      const ops: {\n        attr: PropertyMap\n        data: PropertyMap\n        style: StylePropertyMap\n        styleVar: PropertyMap\n      } = {\n        attr: {},\n        data: {},\n        style: {},\n        styleVar: {},\n      }\n      propertyMapToOpDef(draft, 'attr', ops)\n      propertyMapToOpDef(draft, 'data', ops)\n      propertyMapToOpDef(draft, 'style', ops)\n      propertyMapToOpDef(draft, 'styleVar', ops)\n      forIn(ops, (opsMap, type) => {\n        forIn(opsMap as unknown as PropertyMap, (value, field) => {\n          if (is.unit(value)) {\n            draft.seq.push({type, field, value})\n            processStoreRef(value)\n          } else {\n            draft.staticSeq.push({type, field, value})\n          }\n        })\n      })\n      draft.text.forEach(item => {\n        if (item.value === null) return\n        if (is.unit(item.value)) {\n          draft.seq.push({\n            type: 'dynamicText',\n            value: item.value,\n            childIndex: item.index,\n          })\n          processStoreRef(item.value)\n        } else {\n          draft.seq.push({\n            type: 'staticText',\n            value: String(item.value),\n            childIndex: item.index,\n          })\n        }\n      })\n      draft.handler.forEach(item => {\n        forIn(item.map, (handler, key) => {\n          draft.seq.push({\n            type: 'handler',\n            for: key,\n            //@ts-expect-error\n            handler,\n            options: item.options,\n            domConfig: item.domConfig,\n          })\n        })\n      })\n      if (stencil) applyStaticOps(stencil, draft.staticSeq)\n      draft.seq.forEach(item => {\n        switch (item.type) {\n          case 'visible': {\n            const {onMount, onState} = mutualSample({\n              mount,\n              state: item.value,\n              onMount: (value, leaf) => ({\n                leaf,\n                value,\n                hydration: leaf.hydration,\n              }),\n              onState: (leaf, value) => ({leaf, value, hydration: false}),\n            })\n            onMount.watch(({leaf, value, hydration}) => {\n              const leafData = leaf.data as LeafDataElement\n              const visibleOp = leafData.ops.visible\n              const parentBlock = leafData.block\n              if (hydration) {\n                forceSetOpValue(value, visibleOp)\n                if (value) {\n                  const visibleSibling = findPreviousVisibleSibling(parentBlock)\n                  let foundElement: DOMElement\n                  if (visibleSibling) {\n                    foundElement = visibleSibling.nextSibling! as DOMElement\n                  } else {\n                    foundElement = findParentDOMElement(parentBlock)!\n                      .firstChild! as DOMElement\n                  }\n                  if (foundElement.nodeName === '#text') {\n                    const emptyText = foundElement\n                    foundElement = foundElement.nextSibling! as DOMElement\n                    emptyText.remove()\n                  }\n                  parentBlock.value = foundElement\n                  parentBlock.visible = true\n                }\n              }\n              const svgRoot = elementTemplate.isSvgRoot\n                ? (parentBlock.value as SVGSVGElement)\n                : null\n              mountChildTemplates(draft, {\n                parentBlockFragment: parentBlock,\n                leaf,\n                node: parentBlock.value,\n                svgRoot,\n              })\n              if (value) {\n                if (leafData.needToCallNode) {\n                  leafData.needToCallNode = false\n                  launch({\n                    target: onMountSync,\n                    params: {\n                      element: leafData.block.value,\n                      fns: draft.node,\n                    },\n                    page: leaf,\n                    defer: true,\n                    //@ts-expect-error\n                    scope: leaf.root.scope,\n                  })\n                }\n              }\n              launch({\n                target: domElementCreated,\n                params: leaf,\n                defer: true,\n                page: leaf,\n                //@ts-expect-error\n                scope: leaf.root.scope,\n              })\n            })\n            merge([onState, onMount]).watch(({leaf, value, hydration}) => {\n              const leafData = leaf.data as LeafDataElement\n              const visibleOp = leafData.ops.visible\n              if (!hydration) {\n                pushOpToQueue(value, visibleOp)\n              }\n            })\n            break\n          }\n          case 'attr':\n          case 'data':\n          case 'style':\n          case 'styleVar': {\n            const fn = propertyOperationBinding[item.type]\n            const immediate = syncOperations.some(\n              ({type, field}) => item.type === type && item.field === field,\n            )\n            const hooks = mutualSample({\n              mount: domElementCreated,\n              state: item.value,\n              onMount: (value, leaf) => ({leaf, value}),\n              onState: (leaf, value) => ({leaf, value}),\n            })\n            if (immediate) {\n              merge([hooks.onState, hooks.onMount]).watch(({leaf, value}) => {\n                fn(readElement(leaf), item.field, value)\n              })\n            } else {\n              createPropsOp(draft, {\n                initCtx(value: DOMProperty, leaf) {\n                  const element = readElement(leaf)\n                  fn(element, item.field, value)\n                  return element\n                },\n                runOp(value, element: DOMElement) {\n                  fn(element, item.field, value)\n                },\n                hooks,\n              })\n            }\n            break\n          }\n          case 'dynamicText':\n            createPropsOp(draft, {\n              initCtx(value: string, leaf) {\n                return installTextNode(leaf, value, item.childIndex)\n              },\n              runOp(value, ctx: TextBlock) {\n                applyText(ctx.value, value)\n              },\n              hooks: mutualSample({\n                mount: domElementCreated,\n                state: item.value,\n                onMount: (value, leaf) => ({leaf, value: String(value)}),\n                onState: (leaf, value) => ({leaf, value: String(value)}),\n              }),\n            })\n            break\n          case 'staticText':\n            domElementCreated.watch(leaf => {\n              installTextNode(leaf, item.value, item.childIndex)\n            })\n            break\n          case 'handler': {\n            const handlerTemplate: Template | null =\n              //@ts-expect-error\n              item.handler.graphite.meta.nativeTemplate || null\n            domElementCreated.watch(leaf => {\n              let page: Leaf | null = null\n              if (handlerTemplate) {\n                let handlerPageFound = false\n                let currentPage: Leaf | null = leaf\n                while (!handlerPageFound && currentPage) {\n                  if (currentPage.template === handlerTemplate) {\n                    handlerPageFound = true\n                    page = currentPage\n                  } else {\n                    currentPage = currentPage.parent\n                  }\n                }\n              } else {\n                page = null //leaf\n              }\n              readElement(leaf).addEventListener(\n                item.for,\n                value => {\n                  if (item.options.prevent) value.preventDefault()\n                  if (item.options.stop) value.stopPropagation()\n                  launch({\n                    target: item.handler,\n                    params: value,\n                    page,\n                    //@ts-expect-error\n                    scope: leaf.root.scope,\n                  })\n                },\n                item.domConfig,\n              )\n            })\n            break\n          }\n        }\n      })\n      mount.watch(leaf => {\n        const leafData = leaf.data as LeafDataElement\n        if (!draft.visible) {\n          const visibleOp = leafData.ops.visible\n          const parentBlock = leafData.block\n          if (leaf.hydration) {\n            forceSetOpValue(true, visibleOp)\n            const visibleSibling = findPreviousVisibleSibling(parentBlock)\n            let foundElement: DOMElement\n            if (visibleSibling) {\n              foundElement = visibleSibling.nextSibling! as DOMElement\n            } else {\n              foundElement = findParentDOMElement(parentBlock)!\n                .firstChild! as DOMElement\n            }\n            if (foundElement.nodeName === '#text') {\n              const emptyText = foundElement\n              foundElement = foundElement.nextSibling! as DOMElement\n              emptyText.remove()\n            }\n            parentBlock.value = foundElement\n            parentBlock.visible = true\n          }\n          const svgRoot = elementTemplate.isSvgRoot\n            ? (parentBlock.value as SVGSVGElement)\n            : null\n          mountChildTemplates(draft, {\n            parentBlockFragment: parentBlock,\n            leaf,\n            node: parentBlock.value,\n            svgRoot,\n          })\n          launch({\n            target: domElementCreated,\n            params: leaf,\n            defer: true,\n            page: leaf,\n            //@ts-expect-error\n            scope: leaf.root.scope,\n          })\n          if (leaf.hydration) {\n            if (leafData.needToCallNode) {\n              leafData.needToCallNode = false\n              launch({\n                target: onMountSync,\n                params: {\n                  element: leafData.block.value,\n                  fns: draft.node,\n                },\n                page: leaf,\n                defer: true,\n                //@ts-expect-error\n                scope: leaf.root.scope,\n              })\n            }\n          } else {\n            pushOpToQueue(true, visibleOp)\n          }\n        }\n      })\n    },\n    env,\n  })\n  setInParentIndex(elementTemplate)\n}\n","import type {Scope} from '../../effector/unit.h'\n\nimport type {\n  DOMElement,\n  NSType,\n  UsingDraft,\n  Leaf,\n  Root,\n  Template,\n} from '../index.h'\n\nimport type {UsingBlock} from '../relation.h'\n\nimport {createOpGroup, createOpQueue} from '../plan'\n\nimport {createTemplate, spawn, currentLeaf} from '../template'\nimport {assert} from '../assert'\nimport {mountFn} from '../mountFn'\n\nfunction getDefaultEnv(): {\n  document: Document\n} {\n  if (typeof document !== 'undefined') return {document}\n  throw Error('your environment has no document')\n}\nexport function using(node: DOMElement, cb: () => any): void\nexport function using(\n  node: DOMElement,\n  opts: {\n    fn: () => void\n    hydrate?: boolean\n    env?: {\n      document: Document\n    }\n    onComplete?: () => void\n    onRoot?: (config: {template: Template; leaf: Leaf}) => void\n    scope?: Scope\n  },\n): void\nexport function using(node: DOMElement, opts: any): void {\n  let cb: () => any\n  let onComplete: (() => void) | undefined\n  let env: {\n    document: Document\n  }\n  let hydrate: boolean\n  let onRoot: ((config: {template: Template; leaf: Leaf}) => void) | undefined\n  let scope: Scope\n  if (typeof opts === 'function') {\n    cb = opts\n    env = getDefaultEnv()\n    hydrate = false\n  } else if (opts) {\n    cb = opts.fn\n    env = opts.env ? opts.env : getDefaultEnv()\n    hydrate = opts.hydrate\n    onComplete = opts.onComplete\n    onRoot = opts.onRoot\n    scope = opts.scope\n  } else throw Error('using() second argument is missing')\n  assert(node, 'using() first argument is missing')\n  const root: Root = {\n    scope: scope!,\n    env,\n    activeSpawns: new Set(),\n    childSpawns: {},\n    leafOps: {},\n  }\n  const namespaceURI = node.namespaceURI\n  const tag = node.tagName.toLowerCase()\n  const ns: NSType =\n    namespaceURI === 'http://www.w3.org/2000/svg'\n      ? 'svg'\n      : tag === 'foreignobject'\n      ? 'foreignObject'\n      : 'html'\n  const draft: UsingDraft = {\n    type: 'using',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n  }\n  const usingTemplate = createTemplate({\n    name: 'using',\n    draft,\n    isSvgRoot: tag === 'svg',\n    namespace: ns,\n    fn(_, {mount}) {\n      cb()\n      mount.watch(mountFn.using)\n    },\n    env,\n  })\n\n  const usingBlock: UsingBlock = {\n    type: 'using',\n    child: [],\n    value: node,\n  }\n  const queue = createOpQueue({onComplete})\n  const rootLeaf = spawn(usingTemplate, {\n    parentLeaf: currentLeaf || null,\n    mountNode: node,\n    svgRoot: usingTemplate.isSvgRoot\n      ? (node as SVGSVGElement)\n      : currentLeaf\n      ? currentLeaf.svgRoot\n      : null,\n    leafData: {\n      type: 'using',\n      draft,\n      element: node,\n      block: usingBlock,\n    },\n    opGroup: createOpGroup(queue),\n    domSubtree: createOpGroup(queue),\n    hydration: hydrate,\n    root,\n  })\n\n  if (onRoot) {\n    onRoot({\n      template: usingTemplate,\n      leaf: rootLeaf,\n    })\n  }\n  if (queue.onDrain && !queue.rafID) {\n    const rs = queue.onDrain\n    queue.onDrain = null\n    rs()\n  }\n}\n","import {launch} from 'effector'\nimport type {Leaf} from './index.h'\nimport {pushOpToQueue} from './plan'\n\nexport function iterateChildLeafs(leaf: Leaf, cb: (child: Leaf) => void) {\n  const childSpawns = leaf.root.childSpawns[leaf.fullID]\n  for (const key in childSpawns) {\n    const childs = childSpawns[key]\n    for (let i = 0; i < childs.length; i++) {\n      cb(childs[i])\n    }\n  }\n}\n\nexport function changeChildLeafsVisible(visible: boolean, leaf: Leaf) {\n  const childLeafIterator = (child: Leaf) => {\n    const data = child.data\n    if (visible && data.type === 'list' && data.pendingUpdate) {\n      const update = data.pendingUpdate\n      data.pendingUpdate = null\n      launch({\n        target: child.template.api.pendingUpdate,\n        params: update,\n        defer: true,\n        page: child,\n        //@ts-expect-error\n        scope: child.root.scope,\n      })\n    }\n    if (visible && data.type === 'route') {\n      if (data.pendingInit) {\n        const update = data.pendingInit.value\n        data.pendingInit = null\n        launch({\n          target: child.template.api.pendingInit,\n          params: update,\n          defer: true,\n          page: child,\n          //@ts-expect-error\n          scope: child.root.scope,\n        })\n      } else if (!data.block.visible) return\n    }\n    switch (data.type) {\n      case 'element':\n        pushOpToQueue(visible, data.ops.visible)\n        break\n      case 'route':\n      case 'list':\n      case 'list item':\n        iterateChildLeafs(child, childLeafIterator)\n        break\n      default:\n        console.log('unsupported type', data.type)\n    }\n  }\n  iterateChildLeafs(leaf, childLeafIterator)\n}\n","import type {Leaf} from './index.h'\n\nimport {pushOpToQueue} from './plan'\nimport {iterateChildLeafs} from './iterateChildLeafs'\n\nfunction unmountChildLeafsNoEvent(leaf: Leaf) {\n  leaf.root.activeSpawns.delete(leaf.fullID)\n  iterateChildLeafs(leaf, unmountLeafTree)\n}\n\nfunction unmountOwnSpawn(leaf: Leaf) {\n  removeItem(leaf, leaf.root.childSpawns[leaf.parent!.fullID][leaf.template.id])\n  removeItem(leaf, leaf.template.pages)\n}\n\nexport function unmountLeafTree(leaf: Leaf) {\n  const {data, root} = leaf\n  switch (data.type) {\n    case 'element': {\n      removeItem(leaf, root.childSpawns[leaf.parent!.fullID][leaf.template.id])\n      function halt(leaf: Leaf) {\n        root.activeSpawns.delete(leaf.fullID)\n        const childSpawns = root.childSpawns[leaf.fullID]\n        delete root.childSpawns[leaf.fullID]\n        delete root.leafOps[leaf.fullID]\n        removeItem(leaf, leaf.template.pages)\n        for (const id in childSpawns) {\n          childSpawns[id].forEach(halt)\n        }\n      }\n      halt(leaf)\n\n      const visibleOp = data.ops.visible\n      pushOpToQueue(false, visibleOp)\n      break\n    }\n    case 'list': {\n      const records = data.records\n      for (let i = 0; i < records.length; i++) {\n        const item = records[i]\n\n        if (item.instance) {\n          unmountLeafTree(item.instance)\n        }\n        item.active = false\n      }\n      leaf.root.activeSpawns.delete(leaf.fullID)\n      unmountOwnSpawn(leaf)\n      break\n    }\n    case 'list item': {\n      const listItemBlock = data.block\n      removeItem(listItemBlock, listItemBlock.parent.child)\n      const leftBlock = listItemBlock.left\n      const rightBlock = listItemBlock.right\n      if (leftBlock) {\n        leftBlock.right = rightBlock\n        if (!rightBlock && listItemBlock.parent.lastChild === listItemBlock) {\n          listItemBlock.parent.lastChild = leftBlock\n        }\n      }\n      if (rightBlock) {\n        rightBlock.left = leftBlock\n      }\n      if (\n        !leftBlock &&\n        !rightBlock &&\n        listItemBlock.parent.lastChild === listItemBlock\n      ) {\n        listItemBlock.parent.lastChild = null\n      }\n      listItemBlock.left = null\n      listItemBlock.right = null\n      unmountChildLeafsNoEvent(leaf)\n      unmountOwnSpawn(leaf)\n      break\n    }\n    // including route item\n    case 'route':\n      unmountChildLeafsNoEvent(leaf)\n      unmountOwnSpawn(leaf)\n      break\n    case 'block':\n    case 'block item':\n    case 'rec':\n    case 'rec item':\n      unmountChildLeafsNoEvent(leaf)\n      break\n    case 'using':\n      break\n    default: {\n      const _: never = data\n    }\n  }\n  delete root.childSpawns[leaf.fullID]\n  delete root.leafOps[leaf.fullID]\n}\n\nfunction removeItem<T>(item: T, list?: T[]) {\n  if (!list) return\n  const index = list.indexOf(item)\n  if (index !== -1) {\n    list.splice(index, 1)\n  }\n}\n","import type {Store} from 'effector'\n\nexport function remap<T extends {[field: string]: any}, S extends keyof T>(\n  store: Store<T>,\n  key: S,\n): Store<T[S]>\nexport function remap<\n  T extends {[field: string]: any},\n  S extends {[field: number]: keyof T} | {[field: string]: keyof T},\n>(\n  store: Store<T>,\n  shape: S,\n): {[K in keyof S]: S[K] extends keyof T ? Store<T[S[K]]> : never}\n\nexport function remap(\n  store: Store<any>,\n  shape: string | Array<any> | {[field: string]: any},\n) {\n  if (Array.isArray(shape)) {\n    return shape.map(key => store.map(value => value[key]))\n  }\n  if (typeof shape === 'object' && shape !== null) {\n    const result = {} as any\n    for (const key in shape) {\n      const projectedKey = shape[key]\n      result[key] = store.map(\n        typeof projectedKey === 'function'\n          ? value => projectedKey(value)\n          : value => value[projectedKey],\n      )\n    }\n    return result\n  }\n  return store.map(value => value[shape])\n}\n","import {\n  Store,\n  Event,\n  is,\n  launch,\n  createStore,\n  createEvent,\n  sample,\n} from 'effector'\n\nimport type {ListItemType, ListType, LeafDataList, Leaf} from '../index.h'\nimport type {LF} from '../relation.h'\n\nimport {beginMark, endMark} from '../platform/mark'\nimport {\n  createOpGroup,\n  createAsyncValue,\n  stopAsyncValue,\n  updateAsyncValue,\n} from '../plan'\nimport {createTemplate, spawn, currentTemplate} from '../template'\nimport {mountChildTemplates, setInParentIndex} from '../mountChild'\nimport {unmountLeafTree} from '../unmount'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {mutualSample} from '../mutualSample'\nimport {changeChildLeafsVisible} from '../iterateChildLeafs'\nimport {remap} from './remap'\n\nexport function list<T, K extends keyof T>(config: {\n  source: Store<T[]>\n  fn: (opts: {store: Store<T>; id: Store<T[K]>}) => void\n  key: T[K] extends string | number | symbol ? K : never\n}): void\nexport function list<T>(config: {\n  source: Store<T[]>\n  fn: (opts: {store: Store<T>; id: Store<number>}) => void\n}): void\nexport function list<T>(\n  source: Store<T[]>,\n  fn: (opts: {store: Store<T>; id: Store<number>}) => void,\n): void\nexport function list<T>(opts: any, maybeFn?: any) {\n  assertClosure(currentTemplate, 'list')\n  if (typeof maybeFn === 'function') {\n    if (is.unit(opts)) {\n      opts = {source: opts, fn: maybeFn}\n    } else {\n      opts.fn = maybeFn\n    }\n  }\n  const {fn: cb, key, source, fields = []} = opts\n  const getID: (item: T, i: number) => string | number | symbol =\n    key !== undefined\n      ? typeof key === 'function'\n        ? key\n        : (item: any, i: number) => item[key]\n      : (item, i) => i\n  const draft: ListType = {\n    type: 'list',\n    key: is.store(opts) ? {type: 'index'} : {type: 'key', key: opts.key},\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n  }\n  const {env, namespace} = currentTemplate\n\n  const listTemplate = createTemplate({\n    name: 'list',\n    draft,\n    isSvgRoot: false,\n    namespace,\n    fn(_, {mount}) {\n      const listItemTemplate = createTemplate<{\n        itemUpdater: any\n      }>({\n        name: 'list item',\n        state: {id: -1, store: null},\n        draft,\n        isSvgRoot: false,\n        namespace,\n        fn({id, store}, {mount}) {\n          cb({store, key: id, fields: remap(store, fields)})\n          //@ts-expect-error\n          const itemUpdater = createEvent<any>({named: 'itemUpdater'})\n          store.on(itemUpdater, (_, e) => e)\n          if (draft.itemVisible) {\n            const {onMount: mountAndVisible, onState: onVisibleChanges} =\n              mutualSample({\n                mount,\n                state: draft.itemVisible,\n                onMount: (visible, leaf) => ({visible, leaf}),\n                onState: (leaf, visible) => ({visible, leaf}),\n              })\n            mountAndVisible.watch(({visible, leaf}) => {\n              const parentBlock = leaf.data.block as LF\n              parentBlock.visible = visible\n              parentBlock.childInitialized = visible\n              if (visible) {\n                mountChildTemplates(draft, {\n                  parentBlockFragment: parentBlock,\n                  leaf,\n                })\n              }\n            })\n            onVisibleChanges.watch(({visible, leaf}) => {\n              const parentBlock = leaf.data.block as LF\n              parentBlock.visible = visible\n              if (!parentBlock.childInitialized) {\n                if (visible) {\n                  parentBlock.childInitialized = true\n                  mountChildTemplates(draft, {\n                    parentBlockFragment: parentBlock,\n                    leaf,\n                  })\n                }\n                return\n              }\n              changeChildLeafsVisible(visible, leaf)\n            })\n          } else {\n            mount.watch(mountFn.listItem)\n          }\n          return {\n            itemUpdater,\n          }\n        },\n        env,\n      })\n      const updates = createStore<ListItemType[]>([])\n      const mappedUpdates = source.map((x: any) => x)\n      const mountData = sample({\n        source: source as Store<T[]>,\n        clock: mount,\n        fn: (data, leaf) => {\n          return {\n            updates: data,\n            leaf,\n            hydration: leaf.hydration,\n          }\n        },\n        greedy: true,\n      })\n\n      const pendingUpdate = createEvent<T[]>()\n      const parentNodeUpdateSpawn = sample({\n        source: mountData,\n        clock: [mappedUpdates, pendingUpdate] as [Store<T[]>, Event<T[]>],\n        fn: ({leaf}, updates: T[]) => ({\n          updates,\n          leaf,\n          hydration: false,\n        }),\n        greedy: true,\n      })\n      sample({\n        source: updates,\n        clock: [mountData, parentNodeUpdateSpawn],\n        greedy: true,\n        fn(\n          records: ListItemType[],\n          {updates: input, leaf, hydration},\n        ): ListItemType[] {\n          const listData = leaf.data as LeafDataList\n          let curLeaf: Leaf | null = leaf\n          while (curLeaf) {\n            if (curLeaf.data.type === 'route' && !curLeaf.data.block.visible) {\n              listData.pendingUpdate = input\n              //@ts-expect-error skip updates\n              return\n            }\n            curLeaf = curLeaf.parent\n          }\n          const parentBlock = listData.block\n          beginMark('list update [' + source.shortName + ']')\n          const skipNode: boolean[] = Array(input.length).fill(false)\n          const keys = input.map(getID)\n          const resultRecords: ListItemType[] = []\n          for (let i = 0; i < records.length; i++) {\n            const record = records[i]\n            const index = keys.indexOf(record.key)\n            if (index !== -1) {\n              resultRecords.push(record)\n              skipNode[index] = true\n              updateAsyncValue(input[index], record.asyncValue)\n            } else {\n              record.active = false\n              if (record.instance) {\n                unmountLeafTree(record.instance)\n              }\n              stopAsyncValue(record.asyncValue)\n            }\n          }\n          for (let i = 0; i < input.length; i++) {\n            if (skipNode[i]) continue\n            const value = input[i]\n            const id = keys[i]\n            const group = createOpGroup(\n              leaf.root.leafOps[leaf.fullID].group.queue,\n            )\n            const listItemBlock: LF = {\n              type: 'LF',\n              parent: parentBlock,\n              child: [],\n              childInitialized: false,\n              visible: false,\n              left: null,\n              right: null,\n            }\n            const item: ListItemType = {\n              type: 'listItem',\n              key: id as string,\n              index: id as number,\n              active: true,\n              leafData: {\n                type: 'list item',\n                block: listItemBlock,\n                listDraft: draft,\n              },\n              asyncValue: createAsyncValue({\n                value,\n                group,\n                onChange(value) {\n                  if (item.instance) {\n                    launch({\n                      target: item.instance.template.api.itemUpdater,\n                      params: value,\n                      defer: true,\n                      page: item.instance,\n                      //@ts-expect-error\n                      scope: item.instance.root.scope,\n                    })\n                  }\n                },\n                onInit(value) {\n                  if (!item.active) return\n                  if (hydration) return\n                  item.instance = spawn(listItemTemplate, {\n                    values: {\n                      id,\n                      store: value,\n                    },\n                    parentLeaf: leaf,\n                    mountNode: leaf.mountNode,\n                    svgRoot: leaf.svgRoot,\n                    leafData: item.leafData,\n                    opGroup: group,\n                    domSubtree: leaf.root.leafOps[leaf.fullID].domSubtree,\n                    hydration,\n                    root: leaf.root,\n                  })\n                },\n              }),\n            }\n            const inParentIndex = resultRecords.length\n            resultRecords.push(item)\n            const leftSibling =\n              inParentIndex > 0\n                ? resultRecords[inParentIndex - 1].leafData\n                : null\n\n            parentBlock.child.push(listItemBlock)\n            if (leftSibling) {\n              const leftBlock = leftSibling.block\n              listItemBlock.left = leftBlock\n              const rightBlock = leftBlock.right\n              if (rightBlock) {\n                rightBlock.left = listItemBlock\n                listItemBlock.right = rightBlock\n              } else {\n                parentBlock.lastChild = listItemBlock\n              }\n              leftBlock.right = listItemBlock\n            } else {\n              parentBlock.lastChild = listItemBlock\n            }\n            if (hydration) {\n              item.instance = spawn(listItemTemplate, {\n                values: {\n                  id,\n                  store: value,\n                },\n                parentLeaf: leaf,\n                mountNode: leaf.mountNode,\n                svgRoot: leaf.svgRoot,\n                leafData: item.leafData,\n                opGroup: group,\n                domSubtree: leaf.root.leafOps[leaf.fullID].domSubtree,\n                hydration,\n                root: leaf.root,\n              })\n            }\n          }\n          endMark('list update [' + source.shortName + ']')\n          if (resultRecords.length === 0) {\n            parentBlock.lastChild = null\n          }\n          listData.records = resultRecords\n          return resultRecords\n        },\n        target: updates,\n      })\n      return {pendingUpdate}\n    },\n    env,\n  })\n  setInParentIndex(listTemplate)\n}\n","import type {DOMElement} from '../index.h'\n\nimport {currentTemplate} from '../template'\n\nimport {assertClosure} from '../assert'\n\nexport function node(cb: (node: DOMElement) => (() => void) | void) {\n  assertClosure(currentTemplate, 'node')\n  const draft = currentTemplate.draft\n  switch (draft.type) {\n    case 'list':\n    case 'listItem':\n    case 'using':\n    case 'route':\n    case 'rec':\n    case 'recItem':\n    case 'block':\n    case 'blockItem':\n      console.error('node() hook supported only in h() nodes')\n      return\n  }\n  draft.node.push(cb)\n}\n","import {Store, is, launch, createEvent, sample, merge, combine} from 'effector'\n\nimport type {Leaf, LeafDataRoute, RouteDraft} from '../index.h'\n\nimport {createTemplate, currentTemplate} from '../template'\nimport {mountChild, setInParentIndex} from '../mountChild'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {mutualSample} from '../mutualSample'\nimport {changeChildLeafsVisible} from '../iterateChildLeafs'\n\nexport function route<T>(config: {\n  source: Store<T>\n  visible: (value: T) => boolean\n  fn: (config: {store: Store<T>}) => void\n}): void\nexport function route<T, S extends T>(config: {\n  source: Store<T>\n  visible: (value: T) => value is S\n  fn: (config: {store: Store<S>}) => void\n}): void\nexport function route<T>(config: {\n  source: Store<T>\n  visible: Store<boolean>\n  fn: (config: {store: Store<T>}) => void\n}): void\nexport function route<T>({\n  source,\n  visible,\n  fn,\n}: {\n  source: Store<T>\n  visible: Store<boolean> | ((value: T) => boolean)\n  fn: (config: {store: Store<T>}) => void\n}) {\n  assertClosure(currentTemplate, 'route')\n  const draft: RouteDraft = {\n    type: 'route',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: -1,\n  }\n  const {env, namespace} = currentTemplate\n  const routeTemplate = createTemplate({\n    name: 'route',\n    isSvgRoot: false,\n    namespace,\n    env,\n    draft,\n    fn(_, {mount}) {\n      let state: Store<{\n        value: T\n        visible: boolean\n      }>\n      if (is.store(visible)) {\n        state = combine({value: source, visible})\n      } else {\n        const visibleFn = visible as (value: T) => boolean\n        state = source.map(value => ({\n          value,\n          visible: visibleFn(value),\n        }))\n      }\n      const childDraft: RouteDraft = {\n        type: 'route',\n        childTemplates: [],\n        childCount: 0,\n        inParentIndex: -1,\n      }\n      const routeItemTemplate = createTemplate({\n        name: 'route item',\n        isSvgRoot: false,\n        namespace,\n        env,\n        draft: childDraft,\n        state: {store: null},\n        fn({store}, {mount}) {\n          //@ts-expect-error\n          const itemUpdater = createEvent<any>({named: 'itemUpdater'})\n          store.on(itemUpdater, (_, upd) => upd)\n          fn({store})\n          const onValueUpdate = sample({\n            source: mount,\n            clock: state,\n            fn: (leaf, {visible, value}) => ({\n              leaf,\n              visible,\n              value,\n            }),\n            greedy: true,\n          })\n          mount.watch(mountFn.routeItem)\n          onValueUpdate.watch(({leaf, visible, value}) => {\n            const data = leaf.data as LeafDataRoute\n            data.block.visible = visible\n            if (visible) {\n              launch({\n                target: itemUpdater,\n                params: value,\n                defer: true,\n                page: leaf,\n                //@ts-expect-error\n                scope: leaf.root.scope,\n              })\n            }\n            if (visible) {\n              let curLeaf: Leaf | null = leaf.parent\n              while (curLeaf) {\n                if (\n                  curLeaf.data.type === 'route' &&\n                  !curLeaf.data.block.visible\n                ) {\n                  // listData.pendingUpdate = input\n                  return\n                }\n                curLeaf = curLeaf.parent\n              }\n            }\n            changeChildLeafsVisible(visible, leaf)\n          })\n        },\n      })\n      setInParentIndex(routeItemTemplate)\n      const {onMount, onState: onVisibleChange} = mutualSample({\n        mount,\n        state,\n        onMount: ({visible, value}, leaf) => ({\n          leaf,\n          visible,\n          value,\n        }),\n        onState: (leaf, {visible, value}) => ({\n          leaf,\n          visible,\n          value,\n        }),\n      })\n      const pendingInit = createEvent<T>()\n      const pendingInitWithData = sample({\n        source: mount,\n        clock: pendingInit,\n        greedy: true,\n        fn: (leaf, value) => ({leaf, value, visible: true}),\n      })\n      merge([onMount, onVisibleChange, pendingInitWithData]).watch(\n        ({leaf, visible, value}) => {\n          const data = leaf.data as LeafDataRoute\n          data.block.visible = visible\n          /** stop pending route initialization if route become invisible */\n          if (!visible && !data.initialized && data.pendingInit) {\n            data.pendingInit = null\n            return\n          }\n          if (visible && !data.initialized) {\n            let curLeaf: Leaf | null = leaf.parent\n            while (curLeaf) {\n              if (\n                curLeaf.data.type === 'route' &&\n                !curLeaf.data.block.visible\n              ) {\n                data.pendingInit = {value}\n                return\n              }\n              curLeaf = curLeaf.parent\n            }\n          }\n          if (visible && !data.initialized) {\n            mountChild({\n              parentBlockFragment: data.block,\n              leaf,\n              actor: routeItemTemplate,\n              values: {store: value},\n            })\n            data.initialized = true\n          }\n        },\n      )\n      return {pendingInit}\n    },\n  })\n  setInParentIndex(routeTemplate)\n}\n","import {Store, is} from 'effector'\n\nimport {currentTemplate} from '../template'\nimport {assert, assertClosure} from '../assert'\n\nimport {route} from './route'\n\nexport function variant<T, K extends keyof T>({\n  source,\n  cases,\n  key,\n}: {\n  source: Store<T>\n  key: K\n  cases: T[K] extends string\n    ? Record<T[K], (config: {store: Store<T>}) => void>\n    : {\n        [caseName: string]: (config: {store: Store<T>}) => void\n        __: (config: {store: Store<T>}) => void\n      }\n}) {\n  assertClosure(currentTemplate, 'variant')\n  assert(is.unit(source), 'variant({source}) should be unit')\n  let keyReader: (value: any) => any\n\n  if (typeof key === 'function') keyReader = key\n  else if (key == null) keyReader = (value: any) => String(value)\n  else keyReader = (value: any) => String(value[key])\n\n  let defaultCase = false\n\n  for (const caseName in cases) {\n    if (caseName === '__') {\n      defaultCase = true\n      continue\n    }\n    route({\n      source,\n      visible: value => keyReader(value) === caseName,\n      fn: cases[caseName],\n    })\n  }\n  if (defaultCase) {\n    const nonDefaultCases = Object.keys(cases)\n    route({\n      source,\n      visible: value => !nonDefaultCases.includes(keyReader(value)),\n      //@ts-expect-error\n      fn: cases.__,\n    })\n  }\n}\n","import {Store, launch, createEvent} from 'effector'\n\nimport type {RecItemDraft, LeafDataRecItem, RecDraft} from '../index.h'\n\nimport {createTemplate, currentTemplate} from '../template'\nimport {mountChild, setInParentIndex} from '../mountChild'\nimport {iterateChildLeafs} from '../iterateChildLeafs'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {mutualSample} from '../mutualSample'\n\nexport function rec<T>(config: {\n  fn(config: {store: Store<T>}): void\n}): (opts: {store: Store<T>}) => void\nexport function rec<T>(\n  fn: (config: {store: Store<T>; state?: Store<T>}) => void,\n): (opts: {store: Store<T>; state?: Store<T>}) => void\nexport function rec<T>(\n  fnOrConfig:\n    | {\n        fn(config: {store: Store<T>}): void\n      }\n    | ((config: {store: Store<T>; state?: Store<T>}) => void),\n): (opts: {store: Store<T>; state?: Store<T>}) => void {\n  const fn = typeof fnOrConfig === 'function' ? fnOrConfig : fnOrConfig.fn\n  const recDraft: RecDraft = {\n    type: 'rec',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: 0,\n  }\n  const recTemplate = createTemplate<{\n    itemUpdater: any\n  }>({\n    name: 'rec',\n    state: {store: null},\n    isSvgRoot: false,\n    //@ts-expect-error\n    namespace: null,\n    //@ts-expect-error\n    env: null,\n    draft: recDraft,\n    defer: true,\n    isBlock: true,\n    fn({store}, {mount}) {\n      fn({store, state: store})\n      //@ts-expect-error\n      const itemUpdater = createEvent<any>({named: 'itemUpdater'})\n      store.on(itemUpdater, (_, e) => e)\n      mount.watch(mountFn.rec)\n      return {itemUpdater}\n    },\n  })\n  return ({store, state = store}) => {\n    assertClosure(currentTemplate, '(rec instance)')\n    const {env, namespace} = currentTemplate\n    if (recTemplate.deferredInit) recTemplate.deferredInit()\n\n    const recItemDraft: RecItemDraft = {\n      type: 'recItem',\n      childTemplates: [],\n      childCount: 0,\n      inParentIndex: -1,\n    }\n    const recItemTemplate = createTemplate({\n      name: 'rec item',\n      isSvgRoot: false,\n      namespace,\n      env,\n      draft: recItemDraft,\n      fn(_, {mount}) {\n        const {onMount, onState} = mutualSample({\n          state,\n          mount,\n          onMount: (state, leaf) => ({state, leaf}),\n          onState: (leaf, state) => ({state, leaf}),\n        })\n        onState.watch(({state, leaf}) => {\n          iterateChildLeafs(leaf, child => {\n            launch({\n              target: child.template.api.itemUpdater,\n              params: state,\n              defer: true,\n              page: leaf,\n              //@ts-expect-error\n              scope: leaf.root.scope,\n            })\n          })\n        })\n        onMount.watch(({leaf, state}) => {\n          const data = leaf.data as LeafDataRecItem\n          mountChild({\n            parentBlockFragment: data.block,\n            leaf,\n            actor: recTemplate,\n            values: {store: state},\n          })\n        })\n      },\n    })\n    setInParentIndex(recItemTemplate)\n  }\n}\n","import type {Store} from 'effector'\n\nimport {rec} from './rec'\nimport {list} from './list'\n\nexport function tree<\n  T,\n  ChildField extends keyof T,\n  // KeyField extends keyof T\n>(config: {\n  source: Store<T[]>\n  // key: T[KeyField] extends string ? KeyField : never\n  child: T[ChildField] extends T[] ? ChildField : never\n  fn: (config: {store: Store<T>; child: () => void}) => void\n}): void\nexport function tree({\n  source,\n  key,\n  child: childField,\n  fn,\n}: {\n  source: Store<any[]>\n  key?: string\n  child: string\n  fn: Function\n}) {\n  const treeRec = rec<any[]>(({store}) => {\n    list({\n      source: store,\n      key: key!,\n      fn({store}) {\n        const childList = store.map(value => value[childField] || [])\n        fn({\n          store,\n          child() {\n            treeRec({\n              store: childList,\n            })\n          },\n        })\n      },\n    })\n  })\n  treeRec({\n    store: source,\n  })\n}\n","import type {NSType, BlockDraft, BlockItemDraft} from '../index.h'\n\nimport {createTemplate, currentTemplate} from '../template'\nimport {assertClosure} from '../assert'\nimport {mountFn} from '../mountFn'\nimport {setInParentIndex} from '../mountChild'\n\nexport function block({\n  fn,\n  env,\n  namespace = 'html',\n}: {\n  fn: () => void\n  env: any\n  namespace?: NSType\n}): () => void {\n  const blockDraft: BlockDraft = {\n    type: 'block',\n    childTemplates: [],\n    childCount: 0,\n    inParentIndex: 0,\n  }\n  const blockTemplate = createTemplate({\n    name: 'block',\n    isSvgRoot: false,\n    namespace,\n    env,\n    draft: blockDraft,\n    isBlock: true,\n    fn({}, {mount}) {\n      fn()\n      mount.watch(mountFn.block)\n    },\n  })\n  return () => {\n    assertClosure(currentTemplate, '(block instance)')\n    const blockItemDraft: BlockItemDraft = {\n      type: 'blockItem',\n      childTemplates: [],\n      childCount: 0,\n      inParentIndex: -1,\n      itemOf: blockTemplate,\n    }\n    const {env, namespace} = currentTemplate\n    const blockItemTemplate = createTemplate({\n      name: 'block item',\n      isSvgRoot: false,\n      namespace,\n      env,\n      draft: blockItemDraft,\n      fn(_, {mount}) {\n        mount.watch(mountFn.blockItem)\n      },\n    })\n    setInParentIndex(blockItemTemplate)\n  }\n}\n","import type {StoreOrData, DOMProperty} from './index.h'\n\nexport type Word =\n  | StoreOrData<DOMProperty>\n  | StoreOrData<string>\n  | StoreOrData<number>\n\nexport function createWordsArray(\n  x: TemplateStringsArray,\n  args: Array<Word>,\n): Array<Word> {\n  if (args.length === 0) return x as any\n  const words: Array<Word> = [x[0]]\n  for (let i = 0; i < args.length; i++) {\n    words.push(args[i], x[i + 1])\n  }\n  return words\n}\n","import {spec} from './spec'\nimport {Word, createWordsArray} from '../wordsArray'\n\nexport function text(x: TemplateStringsArray, ...args: Array<Word>) {\n  if (Array.isArray(x)) {\n    spec({text: createWordsArray(x, args) as any})\n  } else {\n    spec({text: x as any})\n  }\n}\n","import {combine, is} from 'effector'\nimport {Word, createWordsArray} from '../wordsArray'\n\nexport function val(x: TemplateStringsArray, ...args: Array<Word>) {\n  if (args.every(arg => !is.store(arg)))\n    return createWordsArray(x, args).join('')\n  return combine(args, args => createWordsArray(x, args).join(''))\n}\n","export let now: () => number\n\nif (typeof performance !== 'undefined' && performance.now) {\n  now = () => performance.now()\n} else if (typeof process !== 'undefined' && process.hrtime) {\n  now = () => {\n    const hr = process.hrtime()\n    return (hr[0] * 1e9 + hr[1]) / 1e6\n  }\n} else {\n  now = () => Date.now()\n}\n","import {USE_PERF} from './env'\nimport {now} from './now'\ntype Bucket = {\n  calls: number\n  time: number\n  label: string\n  childTime: number\n}\nexport const measures = new Map<string, Bucket>()\nconst bucketStack: Array<{bucket: Bucket; pendingStart: number}> = []\nconst startMeasure = (label: string) => {\n  let bucket = measures.get(label)\n  if (!bucket) {\n    bucket = {\n      calls: 0,\n      time: 0,\n      label,\n      childTime: 0,\n    }\n    measures.set(label, bucket)\n  }\n  bucket.calls += 1\n  bucketStack.push({bucket, pendingStart: now()})\n}\nconst endMeasure = (label: string) => {\n  const bucket = measures.get(label)!\n  const pendingStart = bucketStack.pop()!.pendingStart\n  const time = now() - pendingStart\n  bucket.time += time\n\n  if (bucketStack.length > 0) {\n    const parent = bucketStack[bucketStack.length - 1].bucket\n    parent.childTime += time\n  }\n}\n\nexport {startMeasure as perfStart, endMeasure as perfEnd}\n\nexport let beginMark: (label: string) => void\nexport let endMark: (label: string) => void\nif (USE_PERF && typeof performance !== 'undefined' && performance.mark) {\n  beginMark = label => {\n    performance.mark('☄️ ' + label + ' start')\n    startMeasure(label)\n  }\n  endMark = label => {\n    endMeasure(label)\n    try {\n      performance.measure('☄️ ' + label, '☄️ ' + label + ' start')\n    } catch (err) {} // Clear marks immediately to avoid growing buffer.\n\n    performance.clearMarks('☄️ ' + label + ' start')\n    performance.clearMeasures('☄️ ' + label)\n  }\n} else {\n  beginMark = label => {\n    startMeasure(label)\n  }\n  endMark = label => {\n    endMeasure(label)\n  }\n}\n","export const raf =\n  typeof requestAnimationFrame !== 'undefined'\n    ? requestAnimationFrame\n    : (cb: Function) => setTimeout(cb, 0)\n\nexport const cancelRaf: (id: number | NodeJS.Timeout) => void =\n  typeof cancelAnimationFrame !== 'undefined'\n    ? cancelAnimationFrame\n    : clearTimeout\n","import type {StateRef, StateRefOp, Node, Cmd} from '../effector/index.h'\nimport type {TemplateHandlers, Template} from './index.h'\n\nconst addRefOp = (ref: StateRef, op: StateRefOp) => {\n  if (!ref.before) ref.before = []\n  ref.before!.push(op as any)\n}\n\nconst includes = <T>(arr: T[], value: T) => arr.includes(value)\n\nexport const handlers: TemplateHandlers = {\n  storeBase(template: Template, plainState: StateRef) {\n    template.plain.push(plainState)\n  },\n  storeOnMap(\n    template: Template,\n    plainState: StateRef,\n    seq: (Cmd | void)[],\n    fromRef: StateRef | false,\n  ) {\n    seq.unshift(template.loader)\n    seq.push(template.upward)\n    if (fromRef) {\n      if (!includes(template.plain, fromRef)) {\n        //if (!includes(seq, template.loader)) {\n        //  seq.unshift(template.loader)\n        //}\n        if (!includes(template.closure, fromRef)) {\n          template.closure.push(fromRef)\n        }\n        addRefOp(plainState, {\n          type: 'closure',\n          of: fromRef,\n        })\n      }\n    } else {\n      //if (!includes(seq, template.loader)) {\n      //  seq.unshift(template.loader)\n      //}\n    }\n  },\n  storeMap(template: Template, plainState: StateRef, linkNode: Node) {\n    if (\n      !includes(template.plain, plainState) &&\n      !includes(linkNode.seq, template.loader)\n    ) {\n      linkNode.seq.unshift(template.loader)\n    }\n  },\n  storeWatch(\n    template: Template,\n    plainState: StateRef,\n    fn: (value: unknown) => unknown,\n  ) {\n    template.watch.push({of: plainState, fn})\n    return true\n  },\n  eventPrepend(template: Template, contramapped: Node) {\n    contramapped.seq.push(template.upward)\n  },\n  combineBase(template: Template, rawShape: StateRef, isFresh: StateRef) {\n    template.plain.push(rawShape, isFresh)\n  },\n  combineField(template: Template, childRef: StateRef, linkNode: Node) {\n    if (!includes(template.plain, childRef)) {\n      linkNode.seq.unshift(template.loader)\n    }\n  },\n  splitBase(template: Template, lastValues: StateRef) {\n    template.plain.push(lastValues)\n  },\n  splitMatchStore(template: Template, storeRef: StateRef, linkNode: Node) {\n    if (!includes(template.plain, storeRef)) {\n      linkNode.seq.unshift(template.loader)\n    }\n  },\n  sampleSource(\n    template: Template,\n    hasSource: StateRef,\n    sourceRef: StateRef,\n    clockState: StateRef,\n  ) {\n    if (hasSource.current) {\n      if (\n        !includes(template.plain, sourceRef) &&\n        !includes(template.closure, sourceRef)\n      ) {\n        template.closure.push(sourceRef)\n      }\n    } else {\n      template.plain.push(sourceRef)\n    }\n    template.plain.push(hasSource)\n    if (!includes(template.plain, clockState)) {\n      template.plain.push(clockState)\n    }\n  },\n  sampleTarget(template: Template, target: Node) {\n    target.seq.push(template.loader)\n  },\n  sampleSourceLoader: (template: Template) => template.loader,\n  sampleSourceUpward: (template: Template, isUpward: boolean) =>\n    isUpward && template.upward,\n}\n","import type {\n  Leaf,\n  LeafDataRoute,\n  RouteDraft,\n  RecDraft,\n  LeafDataRec,\n  BlockDraft,\n  BlockItemDraft,\n  LeafDataBlock,\n  LeafDataBlockItem,\n  LeafDataUsing,\n  LeafDataListItem,\n} from './index.h'\n\nimport {mountChild, mountChildTemplates} from './mountChild'\n\nexport const mountFn = {\n  using(leaf: Leaf) {\n    const data = leaf.data as LeafDataUsing\n    const block = data.block\n    mountChildTemplates(data.draft, {\n      parentBlockFragment: block,\n      leaf,\n    })\n  },\n  routeItem(leaf: Leaf) {\n    const draft = leaf.draft as RouteDraft\n    const data = leaf.data as LeafDataRoute\n    data.block.visible = true\n    mountChildTemplates(draft, {\n      parentBlockFragment: data.block,\n      leaf,\n    })\n  },\n  block(leaf: Leaf) {\n    const draft = leaf.draft as BlockDraft\n    const data = leaf.data as LeafDataBlock\n    mountChildTemplates(draft, {\n      parentBlockFragment: data.block,\n      leaf,\n    })\n  },\n  blockItem(leaf: Leaf) {\n    const draft = leaf.draft as BlockItemDraft\n    const data = leaf.data as LeafDataBlockItem\n    mountChild({\n      parentBlockFragment: data.block,\n      leaf,\n      actor: draft.itemOf,\n    })\n  },\n  rec(leaf: Leaf) {\n    const draft = leaf.draft as RecDraft\n    const data = leaf.data as LeafDataRec\n    mountChildTemplates(draft, {\n      parentBlockFragment: data.block,\n      leaf,\n    })\n  },\n  listItem(leaf: Leaf) {\n    const data = leaf.data as LeafDataListItem\n    const block = data.block\n    block.visible = true\n    block.childInitialized = true\n    mountChildTemplates(data.listDraft, {\n      parentBlockFragment: block,\n      leaf,\n    })\n  },\n}\n"],"names":["removeOpGroupFromQueue","group","priority","cursor","prev","next","queue","last","first","removeOpFromQueue","op","item","status","getOpQueue","activeChilds","forceSetOpValue","value","active","pending","pushOpToQueue","rafID","raf","execQueue","beginMark","start","now","interrupted","quant","props","tree","data","hasPropsTasks","endMark","runOp","hasTreeTasks","hasDataTasks","onDrain","rs","createOp","createOpQueue","onComplete","bind","createOpGroup","ops","createAsyncValue","onInit","onChange","change","init","terminate","stopAsyncValue","updateAsyncValue","escapeTag","String","replace","applyStaticOps","element","defs","i","length","type","field","defMap","isFalse","val","applyStyleVar","style","removeProperty","setProperty","applyStyle","applyDataAttr","dataset","applyAttr","checked","setAttribute","removeAttribute","applyText","textNode","text","replaceData","textContent","createTemplate","fn","state","values","defer","name","draft","isSvgRoot","namespace","env","isBlock","parent","currentTemplate","template","id","templateID","plain","watch","nameMap","pages","closure","childTemplates","handlers","upward","step","filter","upd","scope","stack","page","root","activeSpawns","has","fullID","console","count","stackTemplates","stackPages","currentStackPage","push","node","forEach","targetTemplate","meta","nativeTemplate","includes","indexOf","launch","target","params","error","loader","forkId","graphite","childSpawns","isRecTemplate","startsWith","validTarget","recID","parentPage","api","trigger","mount","createEvent","named","createNode","deferredInit","prevTemplate","withRegion","restore","getCurrent","ref","forkPage","result","getState","current","findRef","targetLeaf","currentLeaf","regRef","reg","ensureLeafHasRef","leaf","addMapItems","record","spawn","parentLeaf","mountNode","svgRoot","leafData","opGroup","domSubtree","hydration","execRef","before","cmd","from","of","runWatchersFrom","list","stop","err","spawnID","previousSpawn","add","leafOps","closureRef","findClosure","stateRef","mountQueue","steps","shift","findParentDOMElement","block","findLastVisibleChildBlock","visible","child","visibleChild","lastChild","left","findPreviousVisibleSiblingBlock","sibling","parentFragment","index","findPreviousVisibleSibling","assert","condition","msg","Error","assertClosure","currentActor","methodName","setInParentIndex","inParentIndex","childCount","warn","mountChildTemplates","parentBlockFragment","actor","mountChild","fragmentParentTypes","parentDomSubtree","routeBlock","initialized","pendingInit","tag","document","createElementNS","createElement","staticSeq","stencil","cloneNode","elementBlock","appendChild","leafData_","needToCallNode","onMount","fns","childSpawn","remove","listBlock","records","pendingUpdate","recBlock","recItemBlock","visibleSibling","after","prepend","mutualSample","onState","sample","source","clock","greedy","forIn","obj","cb","key","handler","options","map","undefined","is","unit","passive","capture","prevent","domConfig","spec","config","itemVisible","attr","firstIndex","Array","isArray","escaped","styleVar","handlerDef","on","ɔ","createPropsOp","initCtx","hooks","opID","opsAmount","ctx","propertyMapToOpDef","slice","installTextNode","childIndex","parentBlock","textBlock","siblingBlock","createTextNode","nextSibling","parentElement","firstChild","processStoreRef","store","templ","h","opts","hasCb","hasOpts","parentNS","ns","seq","xmlns","elementTemplate","_","domElementCreated","opsMap","for","foundElement","nodeName","emptyText","onMountSync","merge","propertyOperationBinding","immediate","syncOperations","some","readElement","handlerTemplate","handlerPageFound","currentPage","addEventListener","preventDefault","stopPropagation","visibleOp","getDefaultEnv","using","hydrate","onRoot","Set","namespaceURI","tagName","toLowerCase","usingTemplate","mountFn","usingBlock","rootLeaf","iterateChildLeafs","childs","changeChildLeafsVisible","childLeafIterator","update","log","unmountChildLeafsNoEvent","delete","unmountLeafTree","unmountOwnSpawn","removeItem","halt","instance","listItemBlock","leftBlock","rightBlock","right","splice","remap","shape","projectedKey","maybeFn","fields","getID","listItemTemplate","itemUpdater","e","mountAndVisible","onVisibleChanges","childInitialized","listItem","updates","createStore","mappedUpdates","x","mountData","parentNodeUpdateSpawn","input","listData","curLeaf","shortName","skipNode","fill","keys","resultRecords","asyncValue","listDraft","leftSibling","route","routeTemplate","combine","visibleFn","routeItemTemplate","onValueUpdate","routeItem","onVisibleChange","pendingInitWithData","variant","cases","keyReader","defaultCase","caseName","nonDefaultCases","Object","__","rec","fnOrConfig","recTemplate","childField","treeRec","childList","blockTemplate","blockItemDraft","itemOf","blockItem","createWordsArray","args","words","every","arg","join","performance","process","hrtime","hr","Date","measures","Map","bucketStack","startMeasure","label","bucket","get","calls","time","childTime","set","pendingStart","endMeasure","pop","mark","measure","clearMarks","clearMeasures","requestAnimationFrame","setTimeout","arr","storeBase","plainState","storeOnMap","fromRef","unshift","storeMap","linkNode","storeWatch","eventPrepend","contramapped","combineBase","rawShape","isFresh","combineField","childRef","splitBase","lastValues","splitMatchStore","storeRef","sampleSource","hasSource","sourceRef","clockState","sampleTarget","sampleSourceLoader","sampleSourceUpward","isUpward"],"mappings":"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"}